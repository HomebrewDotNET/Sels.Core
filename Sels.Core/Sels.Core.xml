<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sels.Core</name>
    </assembly>
    <members>
        <member name="T:Sels.Core.Guard">
            <summary>
            Contains static helper methods for validating method/constructor parameters.
            </summary>
        </member>
        <member name="M:Sels.Core.Guard.Is(System.Func{System.Boolean},System.Func{System.String})">
            <summary>
            Checks if <paramref name="condition"/> passes. If it doesn't an <see cref="T:System.ArgumentException"/> will be thrown with the message created from <paramref name="errorMessageConstructor"/>.
            </summary>
            <param name="condition">The condition that must pass</param>
            <param name="errorMessageConstructor">Delegate that creates the error message</param>
        </member>
        <member name="M:Sels.Core.Guard.Is(System.Func{System.Boolean},System.Func{System.Exception})">
            <summary>
            Checks if <paramref name="condition"/> passes. If it doesn't the exception created by <paramref name="errorMessageConstructor"/> will be thrown.
            </summary>
            <param name="condition">The condition that must pass</param>
            <param name="errorMessageConstructor">Delegate that creates the exception to throw</param>
        </member>
        <member name="M:Sels.Core.Guard.IsNotNull``1(``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null, if it is a <see cref="T:System.ArgumentNullException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsNotNullOrEmpty(System.String,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null or empty, if it is an <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsNotNullOrWhitespace(System.String,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null or empty, if it is an <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsLarger``1(``0,``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is larger than <paramref name="comparator"/>, if it is not, a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="comparator">The value to compare to <paramref name="argument"/></param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsLargerOrEqual``1(``0,``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is larger or equal to <paramref name="comparator"/>, if it is not, a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="comparator">The value to compare to <paramref name="argument"/></param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsSmaller``1(``0,``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is larger than <paramref name="comparator"/>, if it is not, a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="comparator">The value to compare to <paramref name="argument"/></param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsSmallerOrEqual``1(``0,``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is larger or equal to <paramref name="comparator"/>, if it is not, a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="comparator">The value to compare to <paramref name="argument"/></param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsInRange``1(``0,``0,``0,System.Boolean,System.String)">
            <summary>
            Validates that <paramref name="argument"/> falls in the range of <paramref name="low"/> and <paramref name="high"/>, if it is a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="low">The lowest value of the range</param>
            <param name="high">The highest value of the range</param>
            <param name="inclusive">If the value can be equal to <paramref name="low"/> or <paramref name="high"/>. If set to false it can't be</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.IsNotNullOrEmpty``1(``0,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null and contains at least 1 element, if it is an <see cref="T:System.ArgumentException"/> will be thrown.
            </summary>
            <typeparam name="T">Type of the argument to check</typeparam>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.MustExist(System.IO.FileInfo,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null and exists on the filesystem, if it doesn't exists a <see cref="T:System.IO.FileNotFoundException"/> will be thrown.
            </summary>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Guard.MustExist(System.IO.DirectoryInfo,System.String)">
            <summary>
            Validates that <paramref name="argument"/> is not null and exists on the filesystem, if it doesn't exists a <see cref="T:System.IO.DirectoryNotFoundException"/> will be thrown.
            </summary>
            <param name="argument">The argument instance to check</param>
            <param name="expression">The expression of the argument being checked. Compiler will fill it out automatically so no need to provide it</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="T:Sels.Core.Collections.EqualityHashSet`1">
            <summary>
            Wrapper of a <see cref="T:System.Collections.Generic.HashSet`1"/> that offers different methods of equality.
            </summary>
            <typeparam name="T">Type of the objects in the hash set</typeparam>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.#ctor(Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityHashSet`1"/>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.#ctor(System.Int32,Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityHashSet`1"/>
            <param name="capacity">The number of elements that the new list can initially store.</param>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityHashSet`1"/>
            <param name="collection">The collection whose elements are copied to the new list.</param>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Collections.EqualityHashSet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Collections.EqualityList`1">
            <summary>
            Wrapper of a <see cref="T:System.Collections.Generic.List`1"/> that offers different methods of equality.
            </summary>
            <typeparam name="T">Type of the objects in the list</typeparam>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.#ctor(Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityList`1"/>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.#ctor(System.Int32,Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityList`1"/>
            <param name="capacity">The number of elements that the new list can initially store.</param>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.#ctor(System.Collections.Generic.IEnumerable{`0},Sels.Core.Equality.EqualityType,Sels.Core.Display.StringType)">
            <inheritdoc cref="T:Sels.Core.Collections.EqualityList`1"/>
            <param name="collection">The collection whose elements are copied to the new list.</param>
            <param name="type"><inheritdoc cref="T:Sels.Core.Equality.EqualityType"/></param>
            <param name="stringType"><inheritdoc cref="T:Sels.Core.Display.StringType"/></param>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Collections.EqualityList`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Display.StringType">
            <summary>
            Defines how a collection <see cref="M:System.Object.ToString"/> method works.
            </summary>
        </member>
        <member name="F:Sels.Core.Display.StringType.Default">
            <summary>
            The default <see cref="T:System.Collections.Generic.List`1"/> <see cref="M:System.Object.ToString"/>.
            </summary>
        </member>
        <member name="F:Sels.Core.Display.StringType.Formatted">
            <summary>
            Formatted as GenericTypeName[Count].
            </summary>
        </member>
        <member name="F:Sels.Core.Display.StringType.FormattedShort">
            <summary>
            Formatted as GenericTypeName[Count] without including the namespace.
            </summary>
        </member>
        <member name="T:Sels.Core.Equality.EqualityType">
            <summary>
            Defines how an a list equality is performed.
            </summary>
        </member>
        <member name="F:Sels.Core.Equality.EqualityType.Default">
            <summary>
            The default <see cref="T:System.Collections.Generic.List`1"/> equality.
            </summary>
        </member>
        <member name="F:Sels.Core.Equality.EqualityType.Sequence">
            <summary>
            The elements in the list are compared, the order of the elements matters.
            </summary>
        </member>
        <member name="F:Sels.Core.Equality.EqualityType.SequenceUnordered">
            <summary>
            The elements in the list are compared, the order of the elements doesn't matter.
            </summary>
        </member>
        <member name="F:Sels.Core.Equality.EqualityType.None">
            <summary>
            No equality checks are done. Will always return true.
            </summary>
        </member>
        <member name="T:Sels.Core.Records.RecordProperty`1">
            <summary>
            A struct who's equality check is delegated to a delegate or always returns true when no delegate is provided. Useful in records for defining extra properties not to include in the equality check of the record or when custom equality checks are needed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Sels.Core.Records.RecordProperty`1.Value">
            <summary>
            The value of the property.
            </summary>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.#ctor(Sels.Core.Delegates.Comparator{`0})">
            <inheritdoc cref="T:Sels.Core.Records.RecordProperty`1"/>
            <param name="comparator">Optional delegate used during the equality check of the current instance</param>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.#ctor(`0,Sels.Core.Delegates.Comparator{`0})">
            <inheritdoc cref="T:Sels.Core.Records.RecordProperty`1"/>
            <param name="value"><inheritdoc cref="P:Sels.Core.Records.RecordProperty`1.Value"/></param>
            <param name="comparator">Optional delegate used during the equality check of the current instance</param>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.ActualEquals(System.Object)">
            <summary>
            Checks if the current instance is actually equal to <paramref name="obj"/>.
            </summary>
            <param name="obj">The object to compare to the current instance</param>
            <returns>True if the current instance is equal to <paramref name="obj"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Records.RecordProperty`1.ToString">
            <inheritdoc/>
        </member>
    </members>
</doc>
