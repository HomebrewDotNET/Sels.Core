<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sels.Core</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Extensions.DependencyInjection.ApplicationRegistrations">
            <summary>
            Contains extension methods for registering services
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.ApplicationRegistrations.RegisterConfigurationService(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Adds <see cref="T:Sels.Core.Components.Configuration.ConfigurationService"/> to the service collection as <see cref="T:Sels.Core.Contracts.Configuration.IConfigurationService"/>
            </summary>
            <param name="services">Collection to add the services to</param>
            <returns><paramref name="services"/> for method chaining</returns>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions">
            <summary>
            Contains extension methods for <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type,Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <paramref name="serviceType"/> with an implementation of type <paramref name="implementationType"/>.
            </summary>
            <param name="services">Service collection to add service to</param>
            <param name="serviceType">Type of service to add to the collection</param>
            <param name="implementationType">Implementation for <paramref name="serviceType"/></param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <typeparamref name="TService"/> with an implementation of type <typeparamref name="TImplementation"/>.
            </summary>
            <typeparam name="TService">Type of service to add to the collection</typeparam>
            <typeparam name="TImplementation">Implementation for <typeparamref name="TService"/></typeparam>
            <param name="services">Service collection to add service to</param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <paramref name="serviceType"/>.
            </summary>
            <param name="services">Service collection to add service to</param>
            <param name="serviceType">Type of service to add to the collection</param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">Type of service to add to the collection</typeparam>
            <param name="services">Service collection to add service to</param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object},Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <paramref name="serviceType"/> with <paramref name="implementationFactory"/> to create the instances.
            </summary>
            <param name="services">Service collection to add service to</param>
            <param name="serviceType">Type of service to add to the collection</param>
            <param name="implementationFactory">Factory that creates instances that implement <paramref name="serviceType"/></param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``1},Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <typeparamref name="TService"/> with <paramref name="implementationFactory"/> to create the instances.
            </summary>
            <typeparam name="TService">Type of service to add to the collection</typeparam>
            <typeparam name="TImplementation">Implementation for <typeparamref name="TService"/></typeparam>
            <param name="services">Service collection to add service to</param>
            <param name="implementationFactory">Factory that creates instances that implement <typeparamref name="TImplementation"/></param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.Register``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0},Sels.Core.Components.IoC.ServiceScope)">
            <summary>
            Registers a service of type <typeparamref name="TService"/> with <paramref name="serviceFactory"/> to create the instances.
            </summary>
            <typeparam name="TService">Type of service to add to the collection</typeparam>
            <param name="services">Service collection to add service to</param>
            <param name="serviceFactory">Factory that creates instances of type <typeparamref name="TService"/></param>
            <param name="scope">Which scope to use for the service</param>
            <returns>Self</returns>
        </member>
        <member name="T:Sels.Core.Attributes.Enumeration.Value.StringEnumValue">
            <summary>
            Used to give an alternate string value to an enum.
            </summary>
        </member>
        <member name="P:Sels.Core.Attributes.Enumeration.Value.StringEnumValue.Value">
            <summary>
            The value assigned to an enum value.
            </summary>
        </member>
        <member name="M:Sels.Core.Attributes.Enumeration.Value.StringEnumValue.#ctor(System.String)">
            <summary>
            Used to give an alternate string value to an enum.
            </summary>
            <param name="value">The value to assign</param>
        </member>
        <member name="T:Sels.Core.Attributes.Enumeration.Value.StringEnumValueExtensions">
            <summary>
            Contains extension methods for getting the string enum value.
            </summary>
        </member>
        <member name="M:Sels.Core.Attributes.Enumeration.Value.StringEnumValueExtensions.GetStringValue(System.Enum)">
            <summary>
            Returns the string value from <see cref="T:Sels.Core.Attributes.Enumeration.Value.StringEnumValue"/> defined on <paramref name="value"/>.
            </summary>
            <param name="value">The enum value to get the string value from</param>
            <returns>The string value for <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Attributes.Enumeration.Value.StringEnumValueExtensions.GetStringValueOrDefault(System.Enum)">
            <summary>
            Returns the string value from <see cref="T:Sels.Core.Attributes.Enumeration.Value.StringEnumValue"/> defined on <paramref name="value"/>. Returns the <see cref="M:System.Object.ToString"/> value of <paramref name="value"/> if no <see cref="T:Sels.Core.Attributes.Enumeration.Value.StringEnumValue"/> attribute is defined.
            </summary>
            <param name="value">The enum value to get the string value from</param>
            <returns>The string value for <paramref name="value"/></returns>
        </member>
        <member name="T:Sels.Core.Components.Configuration.ConfigurationService">
            <inheritdoc cref="T:Sels.Core.Contracts.Configuration.IConfigurationService"/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.#ctor(Microsoft.Extensions.Configuration.IConfiguration)">
            <inheritdoc cref="T:Sels.Core.Components.Configuration.ConfigurationService"/>
            <param name="configuration">The key/value pairs to access application configuration</param>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.GetConnectionString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.Get(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.String}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.Get``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.GetAppSetting(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.String}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.GetAppSetting``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.GetSection(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.Collections.Generic.Dictionary{System.String,System.String}}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Configuration.ConfigurationService.GetSection``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Components.Factory.GenericFactory`1">
            <summary>
            Factory that creates new instances by calling the right constructor based on supplied arguments.
            </summary>
            <typeparam name="T">Type of new instances that factory can create</typeparam>
        </member>
        <member name="P:Sels.Core.Components.Factory.GenericFactory`1.InstanceType">
            <summary>
            Type of new instances that factory can create.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Factory.GenericFactory`1.Create(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Factory.GenericFactory`1.CreateNewInstance``1(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Components.IoC.ServiceScope">
            <summary>
            Scope that dictates when a new instance should be created when the service gets resolved.
            </summary>
        </member>
        <member name="F:Sels.Core.Components.IoC.ServiceScope.Transient">
            <summary>
            A new instance is always created.
            </summary>
        </member>
        <member name="F:Sels.Core.Components.IoC.ServiceScope.Scoped">
            <summary>
            The same instance is resolved within the same scope.
            </summary>
        </member>
        <member name="F:Sels.Core.Components.IoC.ServiceScope.Singleton">
            <summary>
            Only 1 instance is created.
            </summary>
        </member>
        <member name="T:Sels.Core.Components.Logging.LoggingServices">
            <summary>
            Static class that makes it easier to log in projects. Only required to be setup during startup.
            </summary>
        </member>
        <member name="P:Sels.Core.Components.Logging.LoggingServices.Loggers">
            <summary>
            Registered loggers used by the <see cref="T:Sels.Core.Components.Logging.LoggingServices"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.RegisterLoggers(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger})">
            <summary>
            Registers the loggers to be used.
            </summary>
            <param name="loggers">The loggers to use</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.RegisterLogger(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Registers a logger to be used.
            </summary>
            <param name="logger">The logger to use</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Debug(System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Warning(System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(System.Action{System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <summary>
            Perform a logging action using the registered loggers.
            </summary>
            <param name="logAction">Action to perform on loggers</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Logs a message.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(System.Exception)">
            <summary>
            Logs an exception with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>.
            </summary>
            <param name="exception">Exception to log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(Microsoft.Extensions.Logging.LogLevel,System.Exception)">
            <summary>
            Logs an exception.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="exception">Exception to log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(System.String,System.Exception,System.Object[])">
            <summary>
            Logs a exception with an extra message with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Log(Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception,System.Object[])">
            <summary>
            Logs a exception with an extra message.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="message">Message to log</param>
            <param name="exception">Exception to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.Trace(System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceObject(System.Object)">
            <summary>
            Traces an object to the logs serialized to json with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="objectToTrace">Object to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceObject(Microsoft.Extensions.Logging.LogLevel,System.Object)">
            <summary>
            Traces an object to the logs serialized to json.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="objectToTrace">Object to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceObject(System.String,System.Object)">
            <summary>
            Traces an object to the logs serialized to json with an extra message with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="objectToTrace">Object to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceObject(Microsoft.Extensions.Logging.LogLevel,System.String,System.Object)">
            <summary>
            Traces an object to the logs serialized to json with an extra message.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="message">Message to log</param>
            <param name="objectToTrace">Object to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceAction(System.String)">
            <summary>
            Traces how long an action took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="action">Action to trace</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceAction(System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Traces how long an action took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="actionStartMessage">Log message when action starts</param>
            <param name="actionFinishedMessage">Log message when action is finished</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceAction(Microsoft.Extensions.Logging.LogLevel,System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Traces how long an action took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="actionStartMessage">Log message when action starts</param>
            <param name="actionFinishedMessage">Log message when action is finished</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceAction(Microsoft.Extensions.Logging.LogLevel,System.String)">
            <summary>
            Traces how long an action took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="action">Action to trace</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceMethod(System.Object,System.String)">
            <summary>
            Traces how long a method took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="caller">Object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceMethod(Microsoft.Extensions.Logging.LogLevel,System.Object,System.String)">
            <summary>
            Traces how long a method took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="caller">Object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceMethod(System.Type,System.String)">
            <summary>
            Traces how long a method took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="caller">Type of object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.TraceMethod(Microsoft.Extensions.Logging.LogLevel,System.Type,System.String)">
            <summary>
            Traces how long a method took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="caller">Type of object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Components.Logging.LoggingServices.CreateTimedLogger(Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Func{System.TimeSpan,System.String})">
            <summary>
            Creates a logger that logs a message when created and a message when disposed using the elapsed time between creating and disposing the logger.
            </summary>
            <param name="logLevel">Severity level for log</param>
            <param name="beginMessageFunc">Func that creates the start message</param>
            <param name="endMessageFunc">Func that creates the stop message</param>
            <returns>Logger that keeps start of elapsed time since it was created</returns>
        </member>
        <member name="T:Sels.Core.Components.Logging.NullTimedLogger">
            <summary>
            Implements <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> using empty methods.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Logging.NullTimedLogger.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Logging.NullTimedLogger.EndLog(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Logging.NullTimedLogger.Log(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Components.Logging.StopWatchTimedLogger">
            <summary>
            Implements <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> using a <see cref="T:System.Diagnostics.Stopwatch"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Logging.StopWatchTimedLogger.#ctor(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Func{System.TimeSpan,System.String})">
            <inheritdoc cref="T:Sels.Core.Components.Logging.StopWatchTimedLogger"/>
            <param name="logger">The logger to use for tracing</param>
            <param name="logLevel">What log level to use for the begin and end messages</param>
            <param name="beginMessageFunc">The delegate that returns the message to log when the timers starts</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the end message needs to be logged</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.StopWatchTimedLogger.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Func{System.TimeSpan,System.String})">
            <inheritdoc cref="T:Sels.Core.Components.Logging.StopWatchTimedLogger"/>
            <param name="loggers">The loggers to use for tracing</param>
            <param name="logLevel">What log level to use for the begin and end messages</param>
            <param name="beginMessageFunc">The delegate that returns the message to log when the timers starts</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the end message needs to be logged</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.StopWatchTimedLogger.Log(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Logging.StopWatchTimedLogger.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Logging.StopWatchTimedLogger.EndLog(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Components.Logging.TimedLogger">
            <summary>
            Logger that keeps track of the elapsed time since it was started. Allows for logging how long certain actions took to execute.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Logging.TimedLogger.Log(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <summary>
            Used to log a message when the timed logger is still running.
            </summary>
            <param name="loggingAction">Delegate to log something using the internal loggers. Arg is the currently elapsed time since starting the timed logger</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.TimedLogger.EndLog(System.Action{System.TimeSpan,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger}})">
            <summary>
            Used to overwrite the default end message. Internal timer is stopped. Is the same as <see cref="M:Sels.Core.Components.Logging.TimedLogger.Dispose"/>.
            </summary>
            <param name="loggingAction">Delegate to log something using the internal loggers. Arg is the currently elapsed time since starting the timed logger</param>
        </member>
        <member name="M:Sels.Core.Components.Logging.TimedLogger.Dispose">
            <summary>
            Logs the end message.
            </summary>
        </member>
        <member name="T:Sels.Core.Components.Parameters.GlobalParameters">
            <summary>
            User to modify the default values used by <see cref="T:Sels.Core.Components.Parameters.Parameterizer"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.GlobalParameters.AddParameter(System.String,System.Func{System.Object,System.String,System.String},System.Func{System.Object})">
            <summary>
            Adds a global parameter that gets loaded into any Parameterizer that has loadGlobalParameters enabled
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.GlobalParameters.AddParameter(System.String,System.String)">
            <summary>
            Adds a global parameter that gets loaded into any Parameterizer that has loadGlobalParameters enabled
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.GlobalParameters.AddParameter(Sels.Core.Components.Parameters.Parameter)">
            <summary>
            Adds a global parameter that gets loaded into any Parameterizer that has loadGlobalParameters enabled
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.GlobalParameters.AddParameters(Sels.Core.Components.Parameters.Parameter[])">
            <summary>
            Adds multiple global parameters that get loaded into any Parameterizer that has loadGlobalParameters enabled
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.GlobalParameters.AddParameters(System.Collections.Generic.IEnumerable{Sels.Core.Components.Parameters.Parameter})">
            <summary>
            Adds multiple global parameters that get loaded into any Parameterizer that has loadGlobalParameters enabled
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.GenerateNewValue(System.String)">
            <summary>
            Generates a new value using the supplied argument without starting a scope
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.GenerateNewValue(System.Object,System.String)">
            <summary>
            Generates a new value using the supplied argument and scope
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.AddDependency(System.String)">
            <summary>
            Adds a dependency to another parameter by name.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.AddDependency(Sels.Core.Components.Parameters.Parameter)">
            <summary>
            Adds a dependency to another parameter.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.GetParameterValue(System.String,System.String)">
            <summary>
            Gets the value of another parameter
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.BeginScope">
            <summary>
            Creates a new context that can be used to create a new scope
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.GenerateValue(System.Object)">
            <summary>
            Generates new value without argument
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter.GenerateValue(System.Object,System.String)">
            <summary>
            Generate bew value with argument
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter`1.BeginNewScope">
            <summary>
            Creates a new context that can be used to create a new scope
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter`1.GenerateValue(`0)">
            <summary>
            Generates new value without argument
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameter`1.GenerateValue(`0,System.String)">
            <summary>
            Generate bew value with argument
            </summary>
        </member>
        <member name="T:Sels.Core.Components.Parameters.Parameterizer">
            <summary>
            Service that replaces text parameters in a string using parameters who can perform custom code when resolving a parameter value.
            </summary>
        </member>
        <member name="F:Sels.Core.Components.Parameters.Parameterizer.ArgumentSplit">
            <summary>
            The string used to split up a parameter name and it's optional argument.
            </summary>
        </member>
        <member name="P:Sels.Core.Components.Parameters.Parameterizer.Parameters">
            <summary>
            The parameters that this service will use to resolve parameters in the supplied text.
            </summary>
        </member>
        <member name="P:Sels.Core.Components.Parameters.Parameterizer.ParameterPrefix">
            <summary>
            The prefix added in front of the parameters.
            </summary>
        </member>
        <member name="P:Sels.Core.Components.Parameters.Parameterizer.ParameterSuffix">
            <summary>
            The suffix added to close a parameter.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.#ctor(System.Boolean)">
            <summary>
            Service that replaces text parameters in a string using parameters who can perform custom code when resolving a parameter value.
            </summary>
            <param name="loadGlobalParameters">If this service should add the parameters from <see cref="P:Sels.Core.Components.Parameters.GlobalParameters.Parameters"/></param>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameter(System.String,System.Func{System.Object,System.String,System.String},System.Func{System.Object})">
            <summary>
            Adds parameter that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameter(System.String,System.Func{System.String},System.Func{System.Object})">
            <summary>
            Adds parameter that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameter(System.String,System.String)">
            <summary>
            Adds parameter that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameter(System.String,System.Object)">
            <summary>
            Adds parameter that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameter(Sels.Core.Components.Parameters.Parameter)">
            <summary>
            Adds parameter that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameters(Sels.Core.Components.Parameters.Parameter[])">
            <summary>
            Adds multiple parameters that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.AddParameters(System.Collections.Generic.IEnumerable{Sels.Core.Components.Parameters.Parameter})">
            <summary>
            Adds multiple parameters that the parameterizer can use
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameterizer.Apply(System.String)">
            <summary>
            Replaces all parameters in <paramref name="source"/> that this service knows.
            </summary>
            <param name="source">The string to replace the parameters in</param>
            <returns><paramref name="source"/> will all known parameters replaced</returns>
        </member>
        <member name="T:Sels.Core.Components.Parameters.Parameters.CachedParameter">
            <summary>
            Caches generated values by using argument within the same scope
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Parameters.Parameters.CachedParameter.GenerateValue">
            <summary>
            Generates a new value without scope or argument
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sels.Core.Components.Properties.ThreadSafeProperty`1">
            <summary>
            Value wrapper where the getter and setter are threadsafe.
            </summary>
            <typeparam name="TValue">The type of the internal value</typeparam>
        </member>
        <member name="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value">
            <summary>
            Property to get/set the internal value.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.#ctor(`0,System.Object)">
            <inheritdoc cref="T:Sels.Core.Components.Properties.ThreadSafeProperty`1"/>
            <param name="initialValue">The initial value to use for <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/></param>
            <param name="threadLock">The object to use for thread locking. When null a new object will be used</param>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.UseGetter(System.Func{`0,`0})">
            <summary>
            Defines a custom getter triggered when calling the getter on <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/>.
            </summary>
            <param name="getter">The delegate that will be used as getter. The arg is the internally stored value for <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/></param>
            <returns>Current property for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.UseSetter(System.Func{`0,`0})">
            <summary>
            Defines a custom setter triggered when calling the setter on <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/>.
            </summary>
            <param name="setter">The delegate that will be used as setter. The arg is the value to set for <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/></param>
            <returns>Current property for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.ValidIf(System.Predicate{`0},System.Func{`0,System.Exception})">
            <summary>
            Defines delegates for validating the value before setting the internal value.
            </summary>
            <param name="condition">The delegate that checks if the value is valid</param>
            <param name="exceptionBuilder">The delegate that will create the exception to throw when the value isn't valid</param>
            <returns>Current property for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.ValidIf(System.Predicate{`0},System.Func{`0,System.String})">
            <summary>
            Defines delegates for validating the value before setting the internal value.
            </summary>
            <param name="condition">The delegate that checks if the value is valid</param>
            <param name="messageBuilder">The delegate that will create the error message for the <see cref="T:System.ArgumentException"/> to throw when the value isn't valid</param>
            <returns>Current property for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.Execute(System.Action{`0})">
            <summary>
            Executes <paramref name="action"/> using the internal lock so <paramref name="action"/> can be executed atomically without <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/> being modified.
            </summary>
            <param name="action">The action to execute</param>
        </member>
        <member name="M:Sels.Core.Components.Properties.ThreadSafeProperty`1.Execute``1(System.Func{`0,``0})">
            <summary>
            Executes <paramref name="function"/> using the internal lock so <paramref name="function"/> can be executed atomically without <see cref="P:Sels.Core.Components.Properties.ThreadSafeProperty`1.Value"/> being modified.
            </summary>
            <typeparam name="T">Type of object returned from <paramref name="function"/></typeparam>
            <param name="function">The function to execute</param>
            <returns>The value returned from <paramref name="function"/></returns>
        </member>
        <member name="T:Sels.Core.Components.Reflection.Searching.Seeker`1">
            <summary>
            Searches the properties of the supplied object to search for instances of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to search for</typeparam>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean)">
            <summary>
            Searches the properties of the supplied object to search for instances of <typeparamref name="T"/>.
            </summary>
            <param name="logger">Optional logger for tracing</param>
            <param name="ignoreSystemAndMicrosoftTypes">If properties that use microsoft/system types should be ignored for fallthrough</param>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Boolean)">
            <summary>
            Searches the properties of the supplied object to search for instances of <typeparamref name="T"/>.
            </summary>
            <param name="loggers">Optional loggers for tracing</param>
            <param name="ignoreSystemAndMicrosoftTypes">If properties that use microsoft/system types should be ignored for fallthrough</param>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.IgnoreForFallThrough(System.Func{System.Object,System.Reflection.PropertyInfo,System.Object,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.SetSearchable(System.Reflection.BindingFlags)">
            <summary>
            Only properties matching <paramref name="flags"/> will be searched.
            </summary>
            <param name="flags"><inheritdoc cref="T:System.Reflection.BindingFlags"/></param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.ReturnWhen(System.Predicate{`0}[])">
            <inheritdoc/>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.Seeker`1.SearchAll(System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="T:Sels.Core.Components.Reflection.Searching.SeekerExtensions">
            <summary>
            Contains extension methods for <see cref="T:Sels.Core.Components.Reflection.Searching.Seeker`1"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.SeekerExtensions.IgnoreSystemTypes``1(Sels.Core.Components.Reflection.Searching.Seeker{``0})">
            <summary>
            Seeker will ignore all properties that have types that start with System. in the namespace.
            </summary>
            <typeparam name="T">Generic type of <paramref name="seeker"/></typeparam>
            <param name="seeker">The seeker to configure</param>
            <returns><paramref name="seeker"/> for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Components.Reflection.Searching.SeekerExtensions.IgnoreMicrosoftTypes``1(Sels.Core.Components.Reflection.Searching.Seeker{``0})">
            <summary>
            Seeker will ignore all properties that have types that start with Microsoft. in the namespace.
            </summary>
            <typeparam name="T">Generic type of <paramref name="seeker"/></typeparam>
            <param name="seeker">The seeker to configure</param>
            <returns><paramref name="seeker"/> for method chaining</returns>
        </member>
        <member name="T:Sels.Core.Components.Scope.Actions.InProcessAction">
            <summary>
            Sets a bool to true when creating this action and sets it to false when it is disposed.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Scope.Actions.InProcessAction.#ctor(System.Action{System.Boolean})">
            <summary>
            Sets a bool to true when creating this action and sets it to false when it is disposed.
            </summary>
            <param name="setter">The action that will get called with the boolean to set</param>
        </member>
        <member name="T:Sels.Core.Components.Scope.AsyncScopedAction">
            <summary>
            Executes an async action when this object gets created and an async action when this object gets disposed.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.#ctor(Sels.Core.Delegates.Async.AsyncAction{System.Threading.CancellationToken},Sels.Core.Delegates.Async.AsyncAction{System.Threading.CancellationToken})">
            <inheritdoc cref="T:Sels.Core.Components.Scope.AsyncScopedAction"/>
            <param name="startAction">The action that is to be executed by <see cref="M:Sels.Core.Components.Scope.AsyncScopedAction.StartAsync(System.Threading.CancellationToken)"/></param>
            <param name="endAction">The action that is to be executed when disposing the scoped action</param>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.#ctor(Sels.Core.Delegates.Async.AsyncAction,Sels.Core.Delegates.Async.AsyncAction{System.Threading.CancellationToken})">
            <inheritdoc cref="T:Sels.Core.Components.Scope.AsyncScopedAction"/>
            <param name="startAction">The action that is to be executed by <see cref="M:Sels.Core.Components.Scope.AsyncScopedAction.StartAsync(System.Threading.CancellationToken)"/></param>
            <param name="endAction">The action that is to be executed when disposing the scoped action</param>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.#ctor(Sels.Core.Delegates.Async.AsyncAction{System.Threading.CancellationToken},Sels.Core.Delegates.Async.AsyncAction)">
            <inheritdoc cref="T:Sels.Core.Components.Scope.AsyncScopedAction"/>
            <param name="startAction">The action that is to be executed by <see cref="M:Sels.Core.Components.Scope.AsyncScopedAction.StartAsync(System.Threading.CancellationToken)"/></param>
            <param name="endAction">The action that is to be executed when disposing the scoped action</param>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.#ctor(Sels.Core.Delegates.Async.AsyncAction,Sels.Core.Delegates.Async.AsyncAction)">
            <inheritdoc cref="T:Sels.Core.Components.Scope.AsyncScopedAction"/>
            <param name="startAction">The action that is to be executed by <see cref="M:Sels.Core.Components.Scope.AsyncScopedAction.StartAsync(System.Threading.CancellationToken)"/></param>
            <param name="endAction">The action that is to be executed when disposing the scoped action</param>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the provided start action.
            </summary>
            <param name="token">Optional token provided to the start/end actions</param>
            <returns>Current scoped action so it can be disposed</returns>
        </member>
        <member name="M:Sels.Core.Components.Scope.AsyncScopedAction.DisposeAsync">
            <summary>
            Triggers to end action.
            </summary>
            <returns>Task to await the result</returns>
        </member>
        <member name="T:Sels.Core.Components.Scope.ScopedAction">
            <summary>
            Executes an action when this object gets created and an action when this object gets disposed.
            </summary>
        </member>
        <member name="M:Sels.Core.Components.Scope.ScopedAction.#ctor(System.Action,System.Action)">
            <summary>
            Creates a new action and executed <paramref name="startAction"/> when this action is constructed.
            </summary>
            <param name="startAction">Action to execute when object is constructed</param>
            <param name="stopAction">Action to execute when object is disposed</param>
        </member>
        <member name="M:Sels.Core.Components.Scope.ScopedAction.Dispose">
            <summary>
            Triggers the stop action.
            </summary>
        </member>
        <member name="T:Sels.Core.RegularExpressions.RegexBuilder">
            <summary>
            Represents a instance used to create regular expressions.
            </summary>
        </member>
        <member name="T:Sels.Core.RegularExpressions.RegexBuilder.Expressions">
            <summary>
            Contains constant values for certain regular expressions.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Expressions.AnyWord">
            <summary>
            Matches everything except linebreaks.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Expressions.AnyWordOptional">
            <summary>
            Matches everything exception linebreaks. Can also match empty string.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Expressions.Any">
            <summary>
            Matches everything.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Expressions.AnyOptional">
            <summary>
            Matches everything. Can also match empty string.
            </summary>
        </member>
        <member name="T:Sels.Core.RegularExpressions.RegexBuilder.Formats">
            <summary>
            Contains formats for certain regular expressions.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Formats.PositiveLookAhead">
            <summary>
            Matches a group after the main expression without including it in the result.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Formats.NegativeLookAhead">
            <summary>
            Specifies a group that can not match after the main expression without including it in the result.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Formats.PositiveLookBehind">
            <summary>
            Matches a group before the main expression without including it in the result.
            </summary>
        </member>
        <member name="F:Sels.Core.RegularExpressions.RegexBuilder.Formats.NegativeLookBehind">
            <summary>
            Specifies a group that can not match before the main expression without including it in the result.
            </summary>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Append(System.String,System.Boolean)">
            <summary>
            Appends <paramref name="value"/> to the internal regex.
            </summary>
            <param name="value">The value to append</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Append(System.Object,System.Boolean)">
            <summary>
            Appends <see cref="M:System.Object.ToString"/> value from <paramref name="value"/> to the internal regex.
            </summary>
            <param name="value">The value to append</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Insert(System.Int32,System.String,System.Boolean)">
            <summary>
            Inserts <paramref name="value"/> at character index <paramref name="index"/> of the internal regex.
            </summary>
            <param name="index">The position in this instance where insertion begins</param>
            <param name="value">The value to insert</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Insert(System.Int32,System.Object,System.Boolean)">
            <summary>
            Inserts <see cref="M:System.Object.ToString"/> value from <paramref name="value"/> at character index <paramref name="index"/> of the internal regex.
            </summary>
            <param name="index">The position in this instance where insertion begins</param>
            <param name="value">The value to insert</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Replace(System.String,System.String,System.Boolean)">
            <summary>
            Replaces <paramref name="oldValue"/> with <paramref name="newValue"/> in the internal regex.
            </summary>
            <param name="oldValue">The value to replace</param>
            <param name="newValue">The value to replace with</param>
            <param name="escape">If <paramref name="newValue"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.Replace(System.Object,System.Object,System.Boolean)">
            <summary>
            Replaces <see cref="M:System.Object.ToString"/> value from <paramref name="oldValue"/> with <see cref="M:System.Object.ToString"/> value from <paramref name="newValue"/> in the internal regex.
            </summary>
            <param name="oldValue">The value to replace</param>
            <param name="newValue">The value to replace with</param>
            <param name="escape">If <paramref name="newValue"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.MatchAnyWord(System.Boolean)">
            <summary>
            Appends an expression that matches any combination excluding linebreaks.
            </summary>
            <param name="isOptional">Set to false if at least 1 characters needs to be matched</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.MatchAny(System.Boolean)">
            <summary>
            Appends an expression that matches any combination.
            </summary>
            <param name="isOptional">Set to false if at least 1 characters needs to be matched</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.LookAhead(System.String,System.Boolean,System.Boolean)">
            <summary>
            Appends a lookahead with <paramref name="value"/>.
            </summary>
            <param name="value">The value to add to the lookahead</param>
            <param name="isMatch">Set to true for a positive lookahead and false for a negative lookahead</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.LookBehind(System.String,System.Boolean,System.Boolean)">
            <summary>
            Appends a lookbehind with <paramref name="value"/>.
            </summary>
            <param name="value">The value to add to the lookbehind</param>
            <param name="isMatch">Set to true for a positive lookbehind and false for a negative lookbehind</param>
            <param name="escape">If <paramref name="value"/> should be escaped</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.ToString">
            <summary>
            Builds the regex of the current builder.
            </summary>
            <returns>The regex string representing the current instance</returns>
        </member>
        <member name="M:Sels.Core.RegularExpressions.RegexBuilder.ToRegex">
            <summary>
            Builds the regex of the current builder.
            </summary>
            <returns>The regex representing the current instance</returns>
        </member>
        <member name="T:Sels.Core.Constants">
            <summary>
            Contains constant/static values used by other components.
            </summary>
        </member>
        <member name="T:Sels.Core.Constants.Strings">
            <summary>
            Contains constant string values.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Strings.Space">
            <summary>
            Contains a space character.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Strings.Tab">
            <summary>
            Contains a tab character.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Strings.Comma">
            <summary>
            Contains a comma character.
            </summary>
        </member>
        <member name="T:Sels.Core.Constants.Configuration">
            <summary>
            Contains constant values for application configuration.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Configuration.DefaultAppSettingsFile">
            <summary>
            The filename of the default configuration file for most .NET applications.
            </summary>
        </member>
        <member name="T:Sels.Core.Constants.Configuration.Sections">
            <summary>
            Contains constants for configuration sections.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Configuration.Sections.AppSettings">
            <summary>
            The name of the default app settings section.
            </summary>
        </member>
        <member name="F:Sels.Core.Constants.Configuration.Sections.ConnectionStrings">
            <summary>
            The name of the default connection strings section.
            </summary>
        </member>
        <member name="T:Sels.Core.Contracts.Configuration.IConfigurationService">
            <summary>
            Service for accessing application configuration.
            </summary>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.GetConnectionString(System.String)">
            <summary>
            Fetches the connection string with name <paramref name="name"/> from the default connection strings section.
            </summary>
            <param name="name">The name of the connection string to fetch</param>
            <returns>The connection string with name <paramref name="name"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.Get``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches configuration value with key <paramref name="key"/>.
            </summary>
            <typeparam name="T">The type of the configuration value to fetch</typeparam>
            <param name="key">The key of the configuration value to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The configuration value with key <paramref name="key"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.Get(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.String}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches configuration value with key <paramref name="key"/>.
            </summary>
            <param name="key">The key of the configuration value to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The configuration value with key <paramref name="key"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.GetAppSetting``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches configuration value with key <paramref name="key"/> from the default app setting section.
            </summary>
            <typeparam name="T">The type of the configuration value to fetch</typeparam>
            <param name="key">The key of the configuration value to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The configuration value with key <paramref name="key"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.GetAppSetting(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.String}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches configuration value with key <paramref name="key"/> from the default app setting section.
            </summary>
            <param name="key">The key of the configuration value to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The configuration value with key <paramref name="key"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.GetSection``1(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{``0}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches section with name <paramref name="section"/>.
            </summary>
            <typeparam name="T">The type that will be creating from the properties of the fetched section</typeparam>
            <param name="section">The name of the section to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The section with name <paramref name="section"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationService.GetSection(System.String,System.Action{Sels.Core.Contracts.Configuration.IConfigurationOptions{System.Collections.Generic.Dictionary{System.String,System.String}}},Sels.Core.Contracts.Configuration.ConfigurationSettings)">
            <summary>
            Fetches section with name <paramref name="section"/>.
            </summary>
            <param name="section">The name of the section to fetch</param>
            <param name="options">Optional action for setting advanced actions that are to be executed when fetching the requested configuration value</param>
            <param name="settings">Optional settings that define extra actions to execute when fetching the requested configuration value</param>
            <returns>The section with name <paramref name="section"/></returns>
        </member>
        <member name="T:Sels.Core.Contracts.Configuration.IConfigurationOptions`1">
            <summary>
            Gives more advanced settings when accessing application configuration.
            </summary>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationOptions`1.SetDefault(`0)">
            <summary>
            Sets the value that will be returned when the requested config value is missing. Is ignored when using <see cref="F:Sels.Core.Contracts.Configuration.ConfigurationSettings.Required"/>.
            </summary>
            <param name="defaultValue">The default value to return</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationOptions`1.FromSection(System.String)">
            <summary>
            Defines a parent section that the requested value will be fetched from. The path will become: {section}:{key}.
            </summary>
            <param name="section">The name of the parent section to fetch the value from</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationOptions`1.FromSection(System.String[])">
            <summary>
            Defines parent sections that the requested value will be fetched from. The path will become: {section[0]}:{section[1]}:{section[2]}:{key}.
            </summary>
            <param name="sections">The parents sections to fetch the requested value from</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationOptions`1.ValidIf(Sels.Core.Delegates.Condition{System.ValueTuple{System.String,`0,System.Boolean}},System.Func{System.ValueTuple{System.String,`0,System.Boolean},System.Exception})">
            <summary>
            The fetched configuration value will be validated using <paramref name="condition"/>. The exception created from <paramref name="errorExceptionFunc"/> will be thrown when the value is invalid.
            </summary>
            <param name="condition">Delegate that checks if the fetched configuration value is valid</param>
            <param name="errorExceptionFunc">Delegate that creates the exception when <paramref name="condition"/> returns false</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Configuration.IConfigurationOptions`1.ValidIf(Sels.Core.Delegates.Condition{System.ValueTuple{System.String,`0,System.Boolean}},System.Func{System.ValueTuple{System.String,`0,System.Boolean},System.String})">
            <summary>
            The fetched configuration value will be validated using <paramref name="condition"/>. An <see cref="T:Sels.Core.Exceptions.Configuration.MisconfiguredException"/> will be thrown using the created error message from <paramref name="errorMessageFunc"/>.
            </summary>
            <param name="condition">Delegate that checks if the fetched configuration value is valid</param>
            <param name="errorMessageFunc">Delegate that creates the error message when <paramref name="condition"/> returns false</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="T:Sels.Core.Contracts.Configuration.ConfigurationSettings">
            <summary>
            Dictates what actions to execute when accessing application configuration.
            </summary>
        </member>
        <member name="F:Sels.Core.Contracts.Configuration.ConfigurationSettings.None">
            <summary>
            No actions need to be executed.
            </summary>
        </member>
        <member name="F:Sels.Core.Contracts.Configuration.ConfigurationSettings.Required">
            <summary>
            An <see cref="T:Sels.Core.Exceptions.Configuration.ConfigurationMissingException"/> will be thrown when the requested configuration is missing.
            </summary>
        </member>
        <member name="T:Sels.Core.Contracts.Factory.IFactory`1">
            <summary>
            Factory that is able to create new instances of <typeparamref name="T"/> based on supplied arguments.
            </summary>
            <typeparam name="T">Type of new instances that factory can create</typeparam>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IFactory`1.Create(System.Object[])">
            <summary>
            Creates a new instance of <paramref name="arguments"/>.
            </summary>
            <param name="arguments">Optional arguments to create a new instance of <typeparamref name="T"/></param>
            <returns>A new instance of <typeparamref name="T"/></returns>
        </member>
        <member name="T:Sels.Core.Contracts.Factory.IServiceFactory">
            <summary>
            A factory that is able to create named/unnamed servics based on the provided type.
            </summary>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.Resolve``1">
            <summary>
            Resolve the first registered service of Type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of service to resolve</typeparam>
            <returns>Registered service of Type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.Resolve``1(System.String)">
            <summary>
            Resolve the registered service of Type <typeparamref name="T"/> with Name <paramref name="name"/>.
            </summary>
            <typeparam name="T">Type of service to resolve</typeparam>
            <param name="name">Name of the service to resolve</param>
            <returns>Registered service of Type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.ResolveAll``1">
            <summary>
            Resolve all services of Type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Type of service to resolve</typeparam>
            <returns>All registered services of Type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.Resolve(System.Type)">
            <summary>
            Resolve the first registered service of Type <paramref name="type"/>.
            </summary>
            <param name="type">Type of service to resolve</param>
            <returns>Registered service of Type <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.Resolve(System.Type,System.String)">
            <summary>
            Resolve the registered service of Type <paramref name="type"/> with Name <paramref name="name"/>.
            </summary>
            <param name="type">Type of service to resolve</param>
            <param name="name">Name of the service to resolve</param>
            <returns>Registered service of Type <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.ResolveAll(System.Type)">
            <summary>
            Resolve all services of Type <paramref name="type"/>
            </summary>
            <param name="type">Type of service to resolve</param>
            <returns>All registered services of Type <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.IsRegistered(System.Type)">
            <summary>
            Checks if this factory can resolve services of Type <paramref name="type"/>.
            </summary>
            <param name="type">Type of service to check</param>
            <returns>Boolean indicating if the factory can resolve services of Type <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.IsRegistered``1">
            <summary>
            Checks if this factory can resolve services of Type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of service to check</typeparam>
            <returns>Boolean indicating if the factory can resolve services of Type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.IsRegistered(System.Type,System.String)">
            <summary>
            Checks if this factory can resolve services of Type <paramref name="type"/> with Name <paramref name="name"/>.
            </summary>
            <param name="type">Type of service to check</param>
            <param name="name">Name of the service to resolve</param>
            <returns>Boolean indicating if the factory can resolve services of Type <paramref name="type"/> with Name <paramref name="name"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.IsRegistered``1(System.String)">
            <summary>
            Checks if this factory can resolve services of Type <typeparamref name="T"/> with Name <paramref name="name"/>.
            </summary>
            <typeparam name="T">Type of service to check</typeparam>
            <param name="name">Name of the service to resolve</param>
            <returns>Boolean indicating if the factory can resolve services of Type <typeparamref name="T"/> with Name <paramref name="name"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.LoadFrom(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Loads all services fron <paramref name="collection"/> into the factory.
            </summary>
            <param name="collection">The collection with the services to add</param>
            <returns>Current factory for method chaning</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Factory.IServiceFactory.CreateChild">
            <summary>
            Creates a copy of the current factory.
            </summary>
            <returns>The new factory</returns>
        </member>
        <member name="T:Sels.Core.Contracts.Mapping.IMapper">
            <summary>
            Generic mapper that can map objects to objects of another type.
            </summary>
        </member>
        <member name="M:Sels.Core.Contracts.Mapping.IMapper.Map``1(System.Object)">
            <summary>
            Maps <paramref name="source"/> to an instance of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to map to</typeparam>
            <param name="source">Object to map</param>
            <returns>Object mapped from <paramref name="source"/></returns>
        </member>
        <member name="T:Sels.Core.Contracts.Mapping.IMapper`2">
            <summary>
            Mapper that can map objects between type <typeparamref name="TLeft"/> and <typeparamref name="TRight"/>.
            </summary>
            <typeparam name="TLeft">Type to map to/from</typeparam>
            <typeparam name="TRight">Type to map to/from</typeparam>
        </member>
        <member name="M:Sels.Core.Contracts.Mapping.IMapper`2.Map(`1)">
            <summary>
            Maps <paramref name="source"/> to an instance of type <typeparamref name="TLeft"/>.
            </summary>
            <param name="source">Object to map</param>
            <returns>Object mapped from <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Mapping.IMapper`2.Map(`0)">
            <summary>
            Maps <paramref name="source"/> to an instance of type <typeparamref name="TRight"/>.
            </summary>
            <param name="source">Object to map</param>
            <returns>Object mapped from <paramref name="source"/></returns>
        </member>
        <member name="T:Sels.Core.Contracts.Reflection.Searching.ISeeker`1">
            <summary>
            Searches through an objects hierarchy and returns all objects matching the defined conditions.
            </summary>
            <typeparam name="T">The object type to search for</typeparam>
        </member>
        <member name="M:Sels.Core.Contracts.Reflection.Searching.ISeeker`1.ReturnWhen(System.Predicate{`0}[])">
            <summary>
            Only objects that pass all <paramref name="conditions"/> will be returned.
            </summary>
            <param name="conditions">The conditions that objects must pass before they are returned by this seeker</param>
            <returns>Current instance for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Contracts.Reflection.Searching.ISeeker`1.SearchAll(System.Object,System.Object[])">
            <summary>
            Searches all properties on <paramref name="objectToSearch"/> and properties on the objects containing in the properties on <paramref name="objectToSearch"/> for all instances of <typeparamref name="T"/>.
            </summary>
            <param name="objectToSearch">The object to search</param>
            <param name="additionalObjectsToSearch">Optional additional objects to search</param>
            <returns>An enumerator that returns all instances of <typeparamref name="T"/> in <paramref name="objectToSearch"/></returns>
        </member>
        <member name="T:Sels.Core.Contracts.Validation.IValidator`2">
            <summary>
            Validator that can validate objects of type <typeparamref name="TEntity"/> and returns validation errors of type <typeparamref name="TError"/>.
            </summary>
            <typeparam name="TEntity">Type of objects to validate</typeparam>
            <typeparam name="TError">Type of validation errors to returns</typeparam>
        </member>
        <member name="T:Sels.Core.Contracts.Validation.IValidator`3">
            <summary>
            Validator that can validate objects of type <typeparamref name="TEntity"/> and returns validation errors of type <typeparamref name="TError"/>.
            </summary>
            <typeparam name="TEntity">Type of objects to validate</typeparam>
            <typeparam name="TError">Type of validation errors to returns</typeparam>
            <typeparam name="TContext">Type of optional context to moddify the behaviour of this validator</typeparam>
        </member>
        <member name="M:Sels.Core.Contracts.Validation.IValidator`3.Validate(`0,`2)">
            <summary>
            Validates <paramref name="entity"/> and returns all validation errors.
            </summary>
            <param name="entity">Entity to validate</param>
            <param name="context">Optional context to modify the behaviour of the validator</param>
            <returns>All validation errors for <paramref name="entity"/></returns>
        </member>
        <member name="M:Sels.Core.Contracts.Validation.IValidator`3.Validate(System.Collections.Generic.IEnumerable{`0},`2)">
            <summary>
            Validates <paramref name="entities"/> and returns all validation errors.
            </summary>
            <param name="entities">Entities to validate</param>
            <param name="context">Optional context to modify the behaviour of the validator</param>
            <returns>All validation errors for <paramref name="entities"/></returns>
        </member>
        <member name="T:Sels.Core.Delegates">
            <summary>
            Contains delegate definitions.
            </summary>
        </member>
        <member name="T:Sels.Core.Delegates.Comparator`1">
            <summary>
            Encapsulates a method that compares to objects of type <typeparamref name="T"/> to see if they are equal, matching, ...
            </summary>
            <typeparam name="T">Type of objects to compare</typeparam>
            <param name="arg1">Object to compare</param>
            <param name="arg2">Object to compare</param>
            <returns>Boolean indicating if arg1 is equal, matching, ... to arg2</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition">
            <summary>
            Encapsulates a method that defines a condition that is checked when calling this delegate.
            </summary>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition`1">
            <summary>
            Encapsulates a method that defines a condition that is checked using the provided arguments when calling this delegate.
            </summary>
            <typeparam name="T">Condition argument</typeparam>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition`2">
            <summary>
            Encapsulates a method that defines a condition that is checked using the provided arguments when calling this delegate.
            </summary>
            <typeparam name="T1">Condition argument</typeparam>
            <typeparam name="T2">Condition argument</typeparam>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition`3">
            <summary>
            Encapsulates a method that defines a condition that is checked using the provided arguments when calling this delegate.
            </summary>
            <typeparam name="T1">Condition argument</typeparam>
            <typeparam name="T2">Condition argument</typeparam>
            <typeparam name="T3">Condition argument</typeparam>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition`4">
            <summary>
            Encapsulates a method that defines a condition that is checked using the provided arguments when calling this delegate.
            </summary>
            <typeparam name="T1">Condition argument</typeparam>
            <typeparam name="T2">Condition argument</typeparam>
            <typeparam name="T3">Condition argument</typeparam>
            <typeparam name="T4">Condition argument</typeparam>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Condition`5">
            <summary>
            Encapsulates a method that defines a condition that is checked using the provided arguments when calling this delegate.
            </summary>
            <typeparam name="T1">Condition argument</typeparam>
            <typeparam name="T2">Condition argument</typeparam>
            <typeparam name="T3">Condition argument</typeparam>
            <typeparam name="T4">Condition argument</typeparam>
            <typeparam name="T5">Condition argument</typeparam>
            <returns>Whether or not this condition passes</returns>
        </member>
        <member name="T:Sels.Core.Delegates.Async">
            <summary>
            Contains async version of existing delegates
            </summary>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncPredicate`1">
            <inheritdoc cref="T:System.Predicate`1"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition`1">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition`1"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition`2">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition`2"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition`3">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition`3"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition`4">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition`4"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncCondition`5">
            <inheritdoc cref="T:Sels.Core.Delegates.Condition`5"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction">
            <inheritdoc cref="T:System.Action"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction`1">
            <inheritdoc cref="T:System.Action`1"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction`2">
            <inheritdoc cref="T:System.Action`2"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction`3">
            <inheritdoc cref="T:System.Action`3"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction`4">
            <inheritdoc cref="T:System.Action`4"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncAction`5">
            <inheritdoc cref="T:System.Action`5"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`1">
            <inheritdoc cref="T:System.Func`1"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`2">
            <inheritdoc cref="T:System.Func`2"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`3">
            <inheritdoc cref="T:System.Func`3"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`4">
            <inheritdoc cref="T:System.Func`4"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`5">
            <inheritdoc cref="T:System.Func`5"/>
        </member>
        <member name="T:Sels.Core.Delegates.Async.AsyncFunc`6">
            <inheritdoc cref="T:System.Func`6"/>
        </member>
        <member name="T:Sels.Core.Exceptions.Configuration.ConfigurationMissingException">
            <summary>
            Indicates that configuration was expected but missing in the config file.
            </summary>
        </member>
        <member name="P:Sels.Core.Exceptions.Configuration.ConfigurationMissingException.MissingKey">
            <summary>
            Configuration key or section name that is missing from config.
            </summary>
        </member>
        <member name="P:Sels.Core.Exceptions.Configuration.ConfigurationMissingException.ConfigFile">
            <summary>
            Configuration file that is missing the needed config key/section
            </summary>
        </member>
        <member name="M:Sels.Core.Exceptions.Configuration.ConfigurationMissingException.#ctor(System.String,System.String,System.Boolean,System.String[])">
            <inheritdoc cref="T:Sels.Core.Exceptions.Configuration.ConfigurationMissingException"/>
            <param name="key">The section or config key that was missing</param>
            <param name="configFile">The config file where the config key is missing from</param>
            <param name="isMissingSection">If the current exception is thrown because of a missing section</param>
            <param name="sections">Optional parent sections for the missing config key</param>
        </member>
        <member name="T:Sels.Core.Exceptions.Configuration.MisconfiguredException">
            <summary>
            Indicates a value in config that is invalid.
            </summary>
        </member>
        <member name="P:Sels.Core.Exceptions.Configuration.MisconfiguredException.ConfigKey">
            <summary>
            Config key/section that was misconfigured.
            </summary>
        </member>
        <member name="P:Sels.Core.Exceptions.Configuration.MisconfiguredException.ConfigFile">
            <summary>
            Configuration file that contains the invalid file.
            </summary>
        </member>
        <member name="P:Sels.Core.Exceptions.Configuration.MisconfiguredException.Reason">
            <summary>
            Reason that <see cref="P:Sels.Core.Exceptions.Configuration.MisconfiguredException.ConfigKey"/> was misconfigured. 
            </summary>
        </member>
        <member name="M:Sels.Core.Exceptions.Configuration.MisconfiguredException.#ctor(System.String,System.String,System.String,System.Boolean,System.String[])">
            <inheritdoc cref="T:Sels.Core.Exceptions.Configuration.MisconfiguredException"/>
            <param name="key">The config key or section that is invalid</param>
            <param name="configFile">The file containing the invalid value</param>
            <param name="reason"></param>
            <param name="isForSection"></param>
            <param name="sections"></param>
        </member>
        <member name="T:Sels.Core.Extensions.Calculation.CalculationExtensions">
            <summary>
            Contains extension for doing math related actions.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Calculation.CalculationExtensions.MultiplyBy(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Multiplies <paramref name="value"/> by <paramref name="multiplyValue"/> <paramref name="times"/> times.
            </summary>
            <param name="value">Value to multiply</param>
            <param name="multiplyValue">Value to multiply <paramref name="value"/> with</param>
            <param name="times">How many times to multiply <paramref name="value"/> with <paramref name="multiplyValue"/></param>
            <returns>Calculated value</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Calculation.CalculationExtensions.MultiplyBy(System.Int64,System.Int64,System.Int32)">
            <summary>
            Multiplies <paramref name="value"/> by <paramref name="multiplyValue"/> <paramref name="times"/> times.
            </summary>
            <param name="value">Value to multiply</param>
            <param name="multiplyValue">Value to multiply <paramref name="value"/> with</param>
            <param name="times">How many times to multiply <paramref name="value"/> with <paramref name="multiplyValue"/></param>
            <returns>Calculated value</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Calculation.CalculationExtensions.DivideBy(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Divides <paramref name="value"/> by <paramref name="divideValue"/> <paramref name="times"/> times.
            </summary>
            <param name="value">Value to divide</param>
            <param name="divideValue">Value to divide <paramref name="value"/> with</param>
            <param name="times">How many times to divide <paramref name="value"/> with <paramref name="divideValue"/></param>
            <returns>Calculated value</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Calculation.CalculationExtensions.DivideBy(System.Int64,System.Int64,System.Int32)">
            <summary>
            Divides <paramref name="value"/> by <paramref name="divideValue"/> <paramref name="times"/> times.
            </summary>
            <param name="value">Value to divide</param>
            <param name="divideValue">Value to divide <paramref name="value"/> with</param>
            <param name="times">How many times to divide <paramref name="value"/> with <paramref name="divideValue"/></param>
            <returns>Calculated value</returns>
        </member>
        <member name="T:Sels.Core.Extensions.Conversion.ConversionExtensions">
            <summary>
            Contains extension methods for converting objects to other types.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.Cast``1(System.Object)">
            <summary>
            Casts <paramref name="source"/> to type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="source">Object to cast</param>
            <returns>Casted object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.CastOrDefault``1(System.Object)">
            <summary>
            Casts <paramref name="source"/> to type <typeparamref name="T"/> if it can be casted, otherwise return default of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="source">Object to cast</param>
            <returns>Casted object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.ChangeType``1(System.Object)">
            <summary>
            Attempts to convert <paramref name="source"/> to an instance of type <typeparamref name="TNew"/>.
            </summary>
            <typeparam name="TNew">The type to convert to</typeparam>
            <param name="source">The object to convert</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.ChangeType(System.Object,System.Type)">
            <summary>
            Attempts to convert <paramref name="source"/> to an instance of type <paramref name="newType"/>.
            </summary>
            <param name="source">The object to convert</param>
            <param name="newType">The type to convert to</param>
            <returns>The converted value</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.ToArrayOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Tranforms <paramref name="items"/> into an array. If <paramref name="items"/> is null an empty array will be created
            </summary>
            <typeparam name="T">Element type of <paramref name="items"/></typeparam>
            <param name="items">Collection to turn into an array</param>
            <returns>A new array of element type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.AsArray``1(``0)">
            <summary>
            Creates a new array containing <paramref name="value"/>.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="value">Value to add to array</param>
            <returns>Array containing <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.AsArrayOrDefault``1(``0)">
            <summary>
            Creates a new array containing <paramref name="value"/> if it is not null, otherwise create an empty array.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="value">Value to add to array</param>
            <returns>Array containing <paramref name="value"/> or empty array</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.AsList``1(``0)">
            <summary>
            Creates a new list containing <paramref name="value"/>.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="value">Value to add to list</param>
            <returns>List containing <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.AsListOrDefault``1(``0)">
            <summary>
            Creates a new list containing <paramref name="value"/> if it is not null, otherwise create an empty array.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="value">Value to add to list</param>
            <returns>List containing <paramref name="value"/> or empty list</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.AsEnumerable``1(``0)">
            <summary>
            Creates an enumerator returning <paramref name="value"/>.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="value">Value to return</param>
            <returns>Enumerator that returns <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.ToUInt32(System.Int32)">
            <summary>
            Converts <paramref name="number"/> to <see cref="T:System.UInt32"/>.
            </summary>
            <param name="number">The number to convert</param>
            <returns><paramref name="number"/> as <see cref="T:System.UInt32"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.ToInt(System.UInt32)">
            <summary>
            Converts <paramref name="number"/> to <see cref="T:System.Int32"/>.
            </summary>
            <param name="number">The number to convert</param>
            <returns><paramref name="number"/> as <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.GroupAsDictionary``3(System.Collections.Generic.IEnumerable{``2},System.Func{``2,``0},System.Func{``2,``1})">
            <summary>
            Creates new dictionary by grouping the items in <paramref name="source"/>. <paramref name="keySelector"/> will select the key for each item and <paramref name="valueSelector"/> will select the value for each item.
            </summary>
            <typeparam name="TKey">Key type for dictionary</typeparam>
            <typeparam name="TValue">Value type for dictionary</typeparam>
            <typeparam name="T">Collection type of <paramref name="source"/></typeparam>
            <param name="source">Items to group</param>
            <param name="keySelector">Func that selects key for each item</param>
            <param name="valueSelector">Func that selects value for each item</param>
            <returns>Dictionary with grouped items from <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Conversion.ConversionExtensions.GroupAsDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Creates new dictionary by grouping the items in <paramref name="source"/>. <paramref name="keySelector"/> will select the key for each item.
            </summary>
            <typeparam name="TKey">Key type for dictionary</typeparam>
            <typeparam name="T">Collection type of <paramref name="source"/></typeparam>
            <param name="source">Items to group</param>
            <param name="keySelector">Func that selects key for each item</param>
            <returns>Dictionary with grouped items from <paramref name="source"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.DependencyInjection.InjectionExtensions">
            <summary>
            Contains extension methods for injecing dependencies into objects.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.DependencyInjection.InjectionExtensions.InjectProperties``1(``0,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Tries to set the values in <paramref name="injectables"/> to the right property in <paramref name="source"/> by comparing the property name and <paramref name="injectables"/> key.
            </summary>
            <typeparam name="T">Type of object to inject</typeparam>
            <param name="source">Object to set properties on</param>
            <param name="injectables">Values to set on <paramref name="source"/></param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.Fluent.FluentExtensions">
            <summary>
            Contains static extension methods for working with api's that use a fluent syntax.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Fluent.FluentExtensions.ForEach``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``0,System.Int32,``1,``0})">
            <summary>
            Executes <paramref name="action"/> for each item in <paramref name="items"/> on <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of the fluent object</typeparam>
            <typeparam name="TItem">Type of the items to perform the action with</typeparam>
            <param name="source">The fluent object to perform the actions on</param>
            <param name="items">Enumerator returning the items to perform <paramref name="action"/> with. Can be null</param>
            <param name="action">Delegate that executes the action. First arg is the last returned fluent object, second arg is the counter and last arg is the item to perform the action with.
            The object returned will be the used for the next item. When null is returned the last non-null object is returned</param>
            <returns><paramref name="source"/> or the last object returned by <paramref name="action"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.GenericExtensions">
            <summary>
            Contains generic extension methods.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.CheckHasValueDynamically(System.Object)">
            <summary>
            Calls HasValue using dynamic. Checks if the object contains information worth processing. Returns false when objects have default types, are empty collections, are empty or whitespace strings, ...
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue(System.Object)">
            <summary>
            Checks if <paramref name="value"/> is not null.
            </summary>
            <param name="value">Object to check</param>
            <returns>Boolean indicating that <paramref name="value"/> is not null</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue(System.String)">
            <summary>
            Checks if <paramref name="value"/> is not null, empty or whitespace.
            </summary>
            <param name="value">Object to check</param>
            <returns>Boolean indicating that <paramref name="value"/> is not null, empty or whitespace</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.IsNull(System.Object)">
            <summary>
            Checks if <paramref name="value"/> is null.
            </summary>
            <param name="value">The object to check</param>
            <returns>True if <paramref name="value"/> is null, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if <paramref name="value"/> is not null and contains at least 1 element.
            </summary>
            <typeparam name="T">Type of the element</typeparam>
            <param name="value">The value to check</param>
            <returns>True if <paramref name="value"/> is not null and contains at least 1 element, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Checks if <paramref name="value"/> is not null and contains at least 1 element that satisfies <paramref name="condition"/>.
            </summary>
            <typeparam name="T">Type of the element</typeparam>
            <param name="value">The value to check</param>
            <param name="condition">The condition that at least 1 element must pass</param>
            <returns>True if <paramref name="value"/> is not null and contains at least 1 element that satisfies <paramref name="condition"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue``1(``0[])">
            <summary>
            Checks if <paramref name="value"/> is not null and contains at least 1 element.
            </summary>
            <typeparam name="T">Type of the element</typeparam>
            <param name="value">The value to check</param>
            <returns>True if <paramref name="value"/> is not null and contains at least 1 element, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.GenericExtensions.HasValue``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Checks if <paramref name="value"/> is not null and contains at least 1 element.
            </summary>
            <typeparam name="T">Type of the element</typeparam>
            <param name="value">The value to check</param>
            <returns>True if <paramref name="value"/> is not null and contains at least 1 element, otherwise false</returns>
        </member>
        <member name="T:Sels.Core.Extensions.Hashing.HashingExtensions">
            <summary>
            Contains extension methods for generating hashes.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Hashing.HashingExtensions.GenerateHash``1(System.Object)">
            <summary>
            Generates a hash from the bytes of <paramref name="sourceObject"/>.
            </summary>
            <typeparam name="THash">The hashing algorithm to use</typeparam>
            <param name="sourceObject">The object to generate the hash for</param>
            <returns>The hash string for <paramref name="sourceObject"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.Linq.Async.AsyncLinqExtensions">
            <summary>
            Extends the Linq extension methods with async variants
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.Async.AsyncLinqExtensions.ExecuteAsync``1(System.Collections.Generic.IEnumerable{``0},Sels.Core.Delegates.Async.AsyncAction{``0})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/> in parallel.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Async action to execute for each element</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.Async.AsyncLinqExtensions.AnyAsync``1(System.Collections.Generic.IEnumerable{``0},Sels.Core.Delegates.Async.AsyncPredicate{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:Sels.Core.Extensions.Linq.LinqExtensions">
            <summary>
            Extra extension methods that follow the same setup as Linq.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.GetCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks how many items are in <paramref name="source"/>. Checks common collection types first to avoid having to enumerate <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of items in <paramref name="source"/></typeparam>
            <param name="source">Enumerator to check</param>
            <returns>Item count of <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.SelectOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Selects a new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/> for each element in <paramref name="source"/>. If <paramref name="source"/> is null an empty enumerator is returned.
            </summary>
            <typeparam name="T">The type to select a new value from</typeparam>
            <typeparam name="TSelect">The type selected from <typeparamref name="T"/></typeparam>
            <param name="source">Enumerator with the elements to select a new value from</param>
            <param name="selector">The func that selects the new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/></param>
            <returns>An enumerator returning all selected values of type <typeparamref name="TSelect"/> from all elements of type  <typeparamref name="T"/> in <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.SelectOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,``0,``1})">
            <summary>
            Selects a new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/> for each element in <paramref name="source"/>. If <paramref name="source"/> is null an empty enumerator is returned.
            </summary>
            <typeparam name="T">The type to select a new value from</typeparam>
            <typeparam name="TSelect">The type selected from <typeparamref name="T"/></typeparam>
            <param name="source">Enumerator with the elements to select a new value from</param>
            <param name="selector">The func that selects the new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/>. First arg is the index, second arg is the element</param>
            <returns>An enumerator returning all selected values of type <typeparamref name="TSelect"/> from all elements of type  <typeparamref name="T"/> in <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Select``2(System.Collections.Generic.IEnumerable{``1},System.Func{System.Int32,``1,``0})">
            <summary>
            Selects a new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">The type to select a new value from</typeparam>
            <typeparam name="TSelect">The type selected from <typeparamref name="T"/></typeparam>
            <param name="source">Enumerator with the elements to select a new value from</param>
            <param name="selector">The func that selects the new value of type <typeparamref name="TSelect"/> from <typeparamref name="T"/>. First arg is the index, second arg is the element</param>
            <returns>An enumerator returning all selected values of type <typeparamref name="TSelect"/> from all elements of type  <typeparamref name="T"/> in <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.ForceSelect``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``0,System.Exception})">
            <summary>
            Projects each element of a sequence into a new form. Exception are caught so execution doesn't stop.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TSelect">The type of the value returned by selector.</typeparam>
            <param name="source"> A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <param name="exceptionHandler">Optional action for handling exceptions. First argument is the element that caused the exception en the second arg is the thrown exception</param>
            <returns>An System.Collections.Generic.IEnumerable`1 whose elements are the result of invoking the transform function on each element of source.</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Modify``1(``0[],System.Predicate{``0},System.Func{``0,``0})">
            <summary>
            Modifies the elements in <paramref name="source"/> matching <paramref name="condition"/> using <paramref name="modifier"/>.
            </summary>
            <typeparam name="T">The type of the elements in <paramref name="source"/></typeparam>
            <param name="source">The array to check</param>
            <param name="condition">The conditions that elements must pass before they are modified</param>
            <param name="modifier">The delegate that modifies the matching elements</param>
            <returns><paramref name="source"/> with the modified elements</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Execute``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Execute``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <param name="exceptionHandler">Delegate that handles exceptions thrown by <paramref name="action"/> before the exception is rethrown</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.ForceExecute``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.ForceExecute``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>. Any exceptions thrown are caught and not rethrown.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <param name="exceptionHandler">Delegate that handles exceptions thrown by <paramref name="action"/> before the exception is rethrown</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Execute``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Int32,``0})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Execute``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Int32,``0},System.Action{System.Int32,``0,System.Exception})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <param name="exceptionHandler">Delegate that handles exceptions thrown by <paramref name="action"/> before the exception is rethrown</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.ForceExecute``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Int32,``0})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.ForceExecute``1(System.Collections.Generic.IEnumerable{``0},System.Action{System.Int32,``0},System.Action{System.Int32,``0,System.Exception})">
            <summary>
            Executes <paramref name="action"/> for each element in <paramref name="source"/>. Any exceptions thrown are caught and not rethrown.
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="source">Enumerator that return the elements</param>
            <param name="action">Action to execute for each element</param>
            <param name="exceptionHandler">Delegate that handles exceptions thrown by <paramref name="action"/> before the exception is rethrown</param>
            <returns><paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.Trim(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an enumerator that trims the values in <paramref name="source"/>.
            </summary>
            <param name="source">Strings to trim</param>
            <returns>An enumerator that trims each element</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Linq.LinqExtensions.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary>
            Tries to get the first instance in <paramref name="source"/> matching <paramref name="condition"/>.
            </summary>
            <typeparam name="T">Type of instance to get</typeparam>
            <param name="source">Enumerator which returns the instances to check</param>
            <param name="condition">What condition an instance in <paramref name="source"/> must pass before it is returned</param>
            <param name="first">The first instance in <paramref name="source"/> matching <paramref name="condition"/> or null if no instance matched <paramref name="condition"/></param>
            <returns>If an instance ;atching <paramref name="condition"/> was found</returns>
        </member>
        <member name="T:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions">
            <summary>
            Exposes some more advanced logging methods.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Debug(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Debug"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Warning(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Warning"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Log(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Log(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Exception)">
            <summary>
            Logs an exception with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>.
            </summary>
            <param name="exception">Exception to log</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Log(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Exception,System.Object[])">
            <summary>
            Logs a exception with an extra message with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Error"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception to log</param>
            <param name="args">Optional logging parameters</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.Trace(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Object[])">
            <summary>
            Logs a message using severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="args">Optional logging parameters</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceAction(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String)">
            <summary>
            Traces how long an action took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="action">Action to trace</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceAction(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Traces how long an action took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Information"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="actionStartMessage">Log message when action starts</param>
            <param name="actionFinishedMessage">Log message when action is finished</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceAction(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Traces how long an action took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="actionStartMessage">Log message when action starts</param>
            <param name="actionFinishedMessage">Log message when action is finished</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceAction(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String)">
            <summary>
            Traces how long an action took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="action">Action to trace</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceMethod(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Object,System.String)">
            <summary>
            Traces how long a method took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="caller">Object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceMethod(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Object,System.String)">
            <summary>
            Traces how long a method took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="caller">Object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceMethod(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Type,System.String)">
            <summary>
            Traces how long a method took to execute with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="caller">Type of object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceMethod(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Type,System.String)">
            <summary>
            Traces how long a method took to execute. Timer starts when calling method and stops when return value is disposed.
            </summary>
            <param name="level">Severity level for log</param>
            <param name="caller">Type of object that wants it's method execution traced</param>
            <param name="method">Name of method to trace. If not provider the calling method name will be used</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
            <returns>Timing scope</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Object)">
            <summary>
            Traces an object to the logs serialized to json with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="objectToTrace">Object to serialize and log</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.Advanced.AdvancedLoggingExtensions.TraceObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.String,System.Object)">
            <summary>
            Traces an object to the logs serialized to json with an extra message with severity <see cref="F:Microsoft.Extensions.Logging.LogLevel.Trace"/>.
            </summary>
            <param name="message">Message to log</param>
            <param name="objectToTrace">Object to serialize and log</param>
            <param name="loggers">Loggers to perform logging action with. If loggers is null nothing will be logged but no exceptions are thrown</param>
        </member>
        <member name="T:Sels.Core.Extensions.Logging.LoggingExtensions">
            <summary>
            Exposes some simple additonal logging methods on ILoggers.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogMessage(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogMessage(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Exception)">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="exception">The exception to log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="exception">The exception to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Exception,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="exception">The exception to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="exception">The exception to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Exception,System.Object[])">
            <summary>
            Logs using <paramref name="logger"/> if it is not null and enabled for log level <paramref name="level"/>.
            </summary>
            <param name="logger">The logger to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="exception">The exception to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogMessage(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogMessage(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Exception)">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="exception">The exception to log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="exception">The exception to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogException(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Exception,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="exception">The exception to log</param>
            <param name="args">Optional arguments for formatting the log message</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Exception,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="message">The message to log</param>
            <param name="exception">The exception to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.LogObject(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Exception,System.Object[])">
            <summary>
            Logs when <paramref name="loggers"/> is not null and with any logger enabled for log level <paramref name="level"/>.
            </summary>
            <param name="loggers">The loggers to use</param>
            <param name="level">The log level for the message</param>
            <param name="messageFunc">The delegate that returns the message to log</param>
            <param name="exception">The exception to log</param>
            <param name="objects">The objects to serialize and log</param>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.CreateTimedLogger(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Creates a <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with <paramref name="logger"/>.
            </summary>
            <param name="logger">The logger to create the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with</param>
            <param name="logLevel">The log level for the logs</param>
            <param name="beginMessage">The message to log when the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> gets created</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the returned <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> is stopped or disposed</param>
            <returns>The <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> created from <paramref name="logger"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.CreateTimedLogger(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.String,System.Func{System.TimeSpan,System.String})">
            <summary>
            Creates a <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with <paramref name="loggers"/>.
            </summary>
            <param name="loggers">The loggers to create the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with</param>
            <param name="logLevel">The log level for the logs</param>
            <param name="beginMessage">The message to log when the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> gets created</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the returned <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> is stopped or disposed</param>
            <returns>The <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> created from <paramref name="loggers"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.CreateTimedLogger(Microsoft.Extensions.Logging.ILogger,Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Func{System.TimeSpan,System.String})">
            <summary>
            Creates a <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with <paramref name="logger"/>.
            </summary>
            <param name="logger">The logger to create the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with</param>
            <param name="logLevel">The log level for the logs</param>
            <param name="beginMessageFunc">The delegate that returns the message to log when the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> gets created</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the returned <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> is stopped or disposed</param>
            <returns>The <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> created from <paramref name="logger"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Logging.LoggingExtensions.CreateTimedLogger(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},Microsoft.Extensions.Logging.LogLevel,System.Func{System.String},System.Func{System.TimeSpan,System.String})">
            <summary>
            Creates a <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with <paramref name="loggers"/>.
            </summary>
            <param name="loggers">The loggers to create the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> with</param>
            <param name="logLevel">The log level for the logs</param>
            <param name="beginMessageFunc">The delegate that returns the message to log when the <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> gets created</param>
            <param name="endMessageFunc">The delegate that returns the message to log when the returned <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> is stopped or disposed</param>
            <returns>The <see cref="T:Sels.Core.Components.Logging.TimedLogger"/> created from <paramref name="loggers"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.ByteExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.ToBase64String(System.Byte[])">
            <summary>
            Converts <paramref name="source"/> to a base 64 string.
            </summary>
            <param name="source">The bytes to convert</param>
            <returns>The base 64 string from <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.ToString``1(System.Byte[])">
            <summary>
            Converts <paramref name="source"/> to a string decoded using encoding of type <typeparamref name="TEncoding"/>.
            </summary>
            <typeparam name="TEncoding">The encoding to use</typeparam>
            <param name="source">The bytes to convert</param>
            <returns>The decoded string from <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes(System.Object)">
            <summary>
            Gets the bytes from object <paramref name="sourceObject"/>.
            </summary>
            <param name="sourceObject">The object to get the bytes from</param>
            <returns>The bytes from <paramref name="sourceObject"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes(System.String)">
            <summary>
            Encodes <paramref name="source"/> using <see cref="T:System.Text.UTF8Encoding"/>.
            </summary>
            <param name="source">The string to encode</param>
            <returns>The encoded string as bytes</returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytesFromBase64(System.String)">
            <summary>
            Encodes <paramref name="source"/> from base 64.
            </summary>
            <param name="source">The string to encode</param>
            <returns>The encoded string as bytes</returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes``1(System.String)">
            <summary>
            Encodes <paramref name="source"/> using encoding of type <typeparamref name="TEncoding"/>.
            </summary>
            <typeparam name="TEncoding">The encoding to use</typeparam>
            <param name="source">The string to encode</param>
            <returns>The encoded string as bytes</returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes(System.Double)">
            <summary>
            Gets the bytes representing <paramref name="source"/>.
            </summary>
            <param name="source">The double to get the bytes from</param>
            <returns>The bytes representing <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes(System.Boolean)">
            <summary>
            Gets the bytes representing <paramref name="source"/>.
            </summary>
            <param name="source">The bool to get the bytes from</param>
            <returns>The bytes representing <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ByteExtensions.GetBytes(System.Char)">
            <summary>
            Gets the bytes representing <paramref name="source"/>.
            </summary>
            <param name="source">The char to get the bytes from</param>
            <returns>The bytes representing <paramref name="source"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.CollectionExtensions">
            <summary>
            Contains extension methods for working with the various .NET collections.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.Enumerate(System.Collections.IEnumerable)">
            <summary>
            Yield return any object in <paramref name="source"/>.
            </summary>
            <param name="source">Collection to get items from</param>
            <returns>Objects in <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.Copy``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new list from the elements in <paramref name="collection"/>.
            </summary>
            <typeparam name="T">Collection element type</typeparam>
            <param name="collection">Collection to get elements from</param>
            <returns>List containing all elements in <paramref name="collection"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.GetAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Gets the element at index <paramref name="index"/> in <paramref name="collection"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="collection"/></typeparam>
            <param name="collection">The collection to get the element from</param>
            <param name="index">The index of the element to get</param>
            <returns>The element at index <paramref name="index"/> in <paramref name="collection"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.AreAllUnique``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if all elements are unique in <paramref name="collection"/> by comparing with <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <typeparam name="T">Collection element type</typeparam>
            <param name="collection">Collection to check</param>
            <returns>Boolean indicating if all elements in <paramref name="collection"/> are unique</returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.AreAllUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object})">
            <summary>
            Checks if all element values selected by <paramref name="valueSelector"/> are unique in <paramref name="collection"/> by comparing with <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <typeparam name="T">Collection element type</typeparam>
            <param name="collection">Collection to check</param>
            <param name="valueSelector">Func that selects the value from <typeparamref name="T"/> to compare</param>
            <returns>Boolean indicating if all elements in <paramref name="collection"/> are unique</returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.GetRandomIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the index of a random element in <paramref name="collection"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="collection"/></typeparam>
            <param name="collection">The collection to get the random element index from</param>
            <returns>The index of a random element in <paramref name="collection"/> or -1 when <paramref name="collection"/> is empty</returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.GetRandomItem``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a random element in <paramref name="collection"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="collection"/></typeparam>
            <param name="collection">The collection to get the random element from</param>
            <returns>A random element in <paramref name="collection"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.Merge``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}})">
            <summary>
            Adds all values in <paramref name="dictionaryToMerge"/> to <paramref name="dictionary"/>.
            </summary>
            <typeparam name="TKey">Type of the key in <paramref name="dictionary"/></typeparam>
            <typeparam name="TItem">Type of the elements in <paramref name="dictionary"/></typeparam>
            <param name="dictionary">The dictionary to add the values to</param>
            <param name="dictionaryToMerge">The dictionary with the values to add</param>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.AddOrUpdate``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds <paramref name="value"/> to <paramref name="dictionary"/> if no entry with <paramref name="key"/> exists, otherwise the value is added using <paramref name="key"/>.
            </summary>
            <typeparam name="TKey">Type of the key in <paramref name="dictionary"/></typeparam>
            <typeparam name="TValue">Type of the value in <paramref name="dictionary"/></typeparam>
            <param name="dictionary">The dictionary to add the value to</param>
            <param name="key">The key to add to</param>
            <param name="value">The value to add</param>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.AddValueToList``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},``0,``1)">
            <summary>
            Adds <paramref name="item"/> to the list of <paramref name="key"/> if <paramref name="key"/> exists in <paramref name="dictionary"/>, otherwise create new list and add <paramref name="item"/> to it.
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TItem">Collection type</typeparam>
            <param name="dictionary">Dictionary to add item to</param>
            <param name="key">Key for list</param>
            <param name="item">Item to add</param>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.AddValues``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},``0,System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Adds <paramref name="items"/> to the list of <paramref name="key"/> if <paramref name="key"/> exists in <paramref name="dictionary"/>, otherwise create new list and add <paramref name="items"/> to it.
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TItem">Collection type</typeparam>
            <param name="dictionary">Dictionary to add item to</param>
            <param name="key">Key for list</param>
            <param name="items">Items to add</param>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.TryGetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value with key <paramref name="key"/> from <paramref name="dictionary"/> if it exists, otherwise <paramref name="value"/> is added and returned.
            </summary>
            <typeparam name="TKey">Type of the key in <paramref name="dictionary"/></typeparam>
            <typeparam name="TValue">Type of the value in <paramref name="dictionary"/></typeparam>
            <param name="dictionary">The dictionary to get the value from</param>
            <param name="key">The key of the value to get</param>
            <param name="value">The value to add if no value is stored under key <paramref name="key"/></param>
            <returns>The value under key <paramref name="key"/>, otherwise <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.TryGetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            Gets the value with key <paramref name="key"/> from <paramref name="dictionary"/> if it exists, otherwise the value created using <paramref name="valueFunc"/> is added and returned.
            </summary>
            <typeparam name="TKey">Type of the key in <paramref name="dictionary"/></typeparam>
            <typeparam name="TValue">Type of the value in <paramref name="dictionary"/></typeparam>
            <param name="dictionary">The dictionary to get the value from</param>
            <param name="key">The key of the value to get</param>
            <param name="valueFunc">The function that creates the value to add if no value is stored under key <paramref name="key"/></param>
            <returns>The value under key <paramref name="key"/>, otherwise the value created from <paramref name="valueFunc"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.ContainsItem``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IEnumerable{``1}},``0,``1)">
            <summary>
            Checks if the enumerator at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>.
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TItem">Type of enumerator element</typeparam>
            <param name="dictionary">The dictionary to check</param>
            <param name="key">The key to check</param>
            <param name="item">The item to check for</param>
            <returns>True if the enumerator at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.ContainsItem``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}},``0,``1)">
            <summary>
            Checks if the list at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>.
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TItem">Type of list element</typeparam>
            <param name="dictionary">The dictionary to check</param>
            <param name="key">The key to check</param>
            <param name="item">The item to check for</param>
            <returns>True if the list at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.CollectionExtensions.ContainsItem``2(System.Collections.Generic.Dictionary{``0,System.Collections.ObjectModel.Collection{``1}},``0,``1)">
            <summary>
            Checks if the collection at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>.
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TItem">Type of list element</typeparam>
            <param name="dictionary">The dictionary to check</param>
            <param name="key">The key to check</param>
            <param name="item">The item to check for</param>
            <returns>True if the collection at key <paramref name="key"/> in <paramref name="dictionary"/> contains <paramref name="item"/>, otherwise false</returns>
        </member>
        <member name="T:Sels.Core.Extensions.DateTimeExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetDifference(System.DateTime)">
            <summary>
            Gets the difference in time between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/>.
            </summary>
            <param name="startDate">Date to compare with <see cref="P:System.DateTime.Now"/></param>
            <returns>Time difference between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetDifference(System.DateTime,System.DateTime)">
            <summary>
            Gets the difference in time between <paramref name="startDate"/> and <paramref name="endDate"/>.
            </summary>
            <param name="startDate">Date to compare with <paramref name="endDate"/></param>
            <param name="endDate">Date to compare with <paramref name="startDate"/></param>
            <returns>Time difference between <paramref name="startDate"/> and <paramref name="endDate"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetMinuteDifference(System.DateTime)">
            <summary>
            Gets the difference in minutes between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/>.
            </summary>
            <param name="startDate">Date to compare with <see cref="P:System.DateTime.Now"/></param>
            <returns>Total minute difference between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetMinuteDifference(System.DateTime,System.DateTime)">
            <summary>
            Gets the difference in minutes between <paramref name="startDate"/> and <paramref name="endDate"/>.
            </summary>
            <param name="startDate">Date to compare with <paramref name="endDate"/></param>
            <param name="endDate">Date to compare with <paramref name="startDate"/></param>
            <returns>Total minute difference between <paramref name="startDate"/> and <paramref name="endDate"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetDayDifference(System.DateTime)">
            <summary>
            Gets the difference in days between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/>.
            </summary>
            <param name="startDate">Date to compare with <see cref="P:System.DateTime.Now"/></param>
            <returns>Total day difference between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetDayDifference(System.DateTime,System.DateTime)">
            <summary>
            Gets the difference in days between <paramref name="startDate"/> and <paramref name="endDate"/>.
            </summary>
            <param name="startDate">Date to compare with <paramref name="endDate"/></param>
            <param name="endDate">Date to compare with <paramref name="startDate"/></param>
            <returns>Total day difference between <paramref name="startDate"/> and <paramref name="endDate"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetYearDifference(System.DateTime)">
            <summary>
            Gets the difference in years between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/>.
            </summary>
            <param name="startDate">Date to compare with <see cref="P:System.DateTime.Now"/></param>
            <returns>Total year difference between <paramref name="startDate"/> and <see cref="P:System.DateTime.Now"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.GetYearDifference(System.DateTime,System.DateTime)">
            <summary>
            Gets the difference in years between <paramref name="startDate"/> and <paramref name="endDate"/>.
            </summary>
            <param name="startDate">Date to compare with <paramref name="endDate"/></param>
            <param name="endDate">Date to compare with <paramref name="startDate"/></param>
            <returns>Total year difference between <paramref name="startDate"/> and <paramref name="endDate"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.IsToday(System.DateTime)">
            <summary>
            Checks if <paramref name="date"/> is on the same day as <see cref="P:System.DateTime.Now"/>.
            </summary>
            <param name="date">The date to check</param>
            <returns>True if <paramref name="date"/> is today, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.IsSameDay(System.DateTime,System.DateTime)">
            <summary>
            Checks if <paramref name="date"/> and <paramref name="otherDate"/> are on the same day and year.
            </summary>
            <param name="date">The date to compare to <paramref name="otherDate"/></param>
            <param name="otherDate">The date to compare to <paramref name="date"/></param>
            <returns>True if <paramref name="date"/> and <paramref name="otherDate"/> are on the same day</returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.IsInPast(System.DateTime)">
            <summary>
            Checks if <paramref name="date"/> is in the past.
            </summary>
            <param name="date">The date to check</param>
            <returns>True if <paramref name="date"/> is smaller than <see cref="P:System.DateTime.Now"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.IsInFuture(System.DateTime)">
            <summary>
            Checks if <paramref name="date"/> is in the future.
            </summary>
            <param name="date">The date to check</param>
            <returns>True if <paramref name="date"/> is larger than <see cref="P:System.DateTime.Now"/>, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.DateTimeExtensions.PrintTotalMs(System.TimeSpan)">
            <summary>
            Returns a formatted string with the total milliseconds of <paramref name="timeSpan"/>.
            </summary>
            <param name="timeSpan">The timespan to get the formatted string from</param>
            <returns>The formatted string with the total milliseconds of <paramref name="timeSpan"/> </returns>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.ActivationExtensions">
            <summary>
            Generic extension methods for creating instances of types through reflection.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ActivationExtensions.CreateList(System.Collections.IEnumerable,System.Type)">
            <summary>
            Creates a generic <see cref="T:System.Collections.Generic.List`1"/> of type <paramref name="listType"/> and adds all elements in <paramref name="source"/> if it not null.
            </summary>
            <param name="source">Enumerable with elelemts to add.</param>
            <param name="listType">The type for the list to create</param>
            <returns>A generic <see cref="T:System.Collections.Generic.List`1"/> of type <paramref name="listType"/> with all types from <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ActivationExtensions.CreateList(System.Type)">
            <summary>
            Creates a generic <see cref="T:System.Collections.Generic.List`1"/> from <paramref name="elementType"/>.
            </summary>
            <param name="elementType">The generic type for the list to create</param>
            <returns>A generic <see cref="T:System.Collections.Generic.List`1"/> of type <paramref name="elementType"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.AttributeExtensions">
            <summary>
            Contains extension methods for working with attributes.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttribute``1(System.Object)">
            <summary>
            Gets the first attribute of type <typeparamref name="T"/> from the type of <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The object to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the attribute could not be found</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the first attribute of type <typeparamref name="T"/> from member <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The member to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the attribute could not be found</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttribute``1(System.Enum)">
            <summary>
            Gets the first attribute of type <typeparamref name="T"/> from enum value <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The enum value to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the attribute could not be found</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttributeOrDefault``1(System.Object)">
            <summary>
            Tries to get the first attribute of type <typeparamref name="T"/> from the type of <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The object to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/> or null if none are found</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttributeOrDefault``1(System.Reflection.MemberInfo)">
            <summary>
            Tries to get the first attribute of type <typeparamref name="T"/> from member <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The member to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/> or null if none are found</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.AttributeExtensions.GetAttributeOrDefault``1(System.Enum)">
            <summary>
            Tries to get the first attribute of type <typeparamref name="T"/> from enum value <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <param name="source">The enum value to get the attribute from</param>
            <returns>The first attribute of type <typeparamref name="T"/> or null if none are found</returns>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.Expression">
            <summary>
            Contains extension methods for working with <see cref="T:System.Linq.Expressions.Expression`1"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.Expression.TryExtractProperty``1(System.Linq.Expressions.Expression{``0},System.Reflection.PropertyInfo@)">
            <summary>
            Tries to extract the <see cref="T:System.Reflection.PropertyInfo"/> if <paramref name="expression"/> points to a property.
            </summary>
            <typeparam name="T">Type of the delegate in <paramref name="expression"/></typeparam>
            <param name="expression">The expression to check</param>
            <param name="property">The property if it could be extracted</param>
            <returns>True if <paramref name="expression"/> points to a property, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.Expression.ExtractProperty``1(System.Linq.Expressions.Expression{``0},System.String)">
            <summary>
            Extracts <see cref="T:System.Reflection.PropertyInfo"/> from <paramref name="expression"/>.
            </summary>
            <typeparam name="T">Type of the delegate in <paramref name="expression"/></typeparam>
            <param name="expression">The expression to check</param>
            <param name="variableName">The name of the expression variable</param>
            <returns>The extracted property</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="expression"/> doesn't point to a property</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.Expression.ExtractProperty``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Extracts <see cref="T:System.Reflection.PropertyInfo"/> from <paramref name="expression"/>.
            </summary>
            <typeparam name="T">Type of the delegate in <paramref name="expression"/></typeparam>
            <param name="expression">The expression to check</param>
            <returns>The extracted property</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.Expression.ExtractPropertyOrDefault(System.Linq.Expressions.Expression)">
            <summary>
            Extracts <see cref="T:System.Reflection.PropertyInfo"/> from <paramref name="expression"/> if the expression points to a property.
            </summary>
            <param name="expression">The expression to check</param>
            <returns>The extracted property or null if <paramref name="expression"/> doesn't point to an expression</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.Expression.ExtractProperties``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Extract the property + any nested properties from <paramref name="expression"/>.
            </summary>
            <typeparam name="T">The type of the lambda expression to extract the properties from</typeparam>
            <param name="expression">The expression to get the properties from</param>
            <returns>All properties extracted from <paramref name="expression"/> in the same order they are defined in <paramref name="expression"/></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.PropertyInfoExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetProperties(System.Object)">
            <summary>
            Gets all property info defined on the type of <paramref name="value"/>.
            </summary>
            <param name="value">The object to get the properties from</param>
            <returns>The properties on <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetProperties(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Gets all property info defined on the type of <paramref name="value"/>.
            </summary>
            <param name="value">The object to get the properties from</param>
            <param name="bindingFlags">Defines what properties to return</param>
            <returns>The properties on <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetPublicProperties(System.Object)">
            <summary>
            Gets all public instance and static properties on the type of <paramref name="value"/>.
            </summary>
            <param name="value">The object to get the properties from</param>
            <returns>The public instance and static properties on <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetPublicProperties(System.Type)">
            <summary>
            Gets all public instance and static properties on <paramref name="type"/>.
            </summary>
            <param name="type">The type to get the properties from</param>
            <returns>The public instance and static properties on <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.AreEqual(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
            Checks if <paramref name="property"/> is the same property as <paramref name="propertyToCompare"/>.
            </summary>
            <param name="property">The first property to compare</param>
            <param name="propertyToCompare">The second property to compare</param>
            <returns>Whether or not <paramref name="property"/> is equal to <paramref name="propertyToCompare"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetValue``1(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Gets the value of property <paramref name="property"/> on instance <paramref name="sourceObject"/> and casts it to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the property value</typeparam>
            <param name="property">The property to get the value from</param>
            <param name="sourceObject">The instance to get the value from</param>
            <returns>The value from <paramref name="property"/> on <paramref name="sourceObject"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.CanAssign``1(System.Reflection.PropertyInfo)">
            <summary>
            Checks if values of type <typeparamref name="T"/> can be assigned to property <paramref name="property"/>.
            </summary>
            <typeparam name="T">The type to check</typeparam>
            <param name="property">The property to check</param>
            <returns>If values of type <typeparamref name="T"/> can be assigned to property <paramref name="property"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.TryGetPropertyInfo(System.Object,System.String,System.Reflection.PropertyInfo@)">
            <summary>
            Tries to extract the property with name <paramref name="propertyName"/> from the type of <paramref name="sourceObject"/>.
            </summary>
            <param name="sourceObject">The object to get the property from</param>
            <param name="propertyName">The name of the property to search for</param>
            <param name="property">The property info if the property was found</param>
            <returns>Whether or not a property was found</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.TryGetPropertyInfo(System.Type,System.String,System.Reflection.PropertyInfo@)">
            <summary>
            Tries to extract the property with name <paramref name="propertyName"/> from <paramref name="sourceType"/>.
            </summary>
            <param name="sourceType">The type to get the property from</param>
            <param name="propertyName">The name of the property to search for</param>
            <param name="property">The property info if the property was found</param>
            <returns>Whether or not a property was found</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetPropertyInfo(System.Object,System.String)">
            <summary>
            Gets the property with name <paramref name="propertyName"/> from the type of <paramref name="sourceObject"/>.
            </summary>
            <param name="sourceObject">The object to get the property from</param>
            <param name="propertyName">The name of the property to search for</param>
            <returns>The property with name <paramref name="propertyName"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the property could not be found</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.GetPropertyInfo(System.Type,System.String)">
            <summary>
            Gets the property with name <paramref name="propertyName"/> from <paramref name="sourceType"/>.
            </summary>
            <param name="sourceType">The type to get the property from</param>
            <param name="propertyName">The name of the property to search for</param>
            <returns>The property with name <paramref name="propertyName"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the property could not be found</exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.PropertyInfoExtensions.SetDefault(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Sets the default value of the property type on property <paramref name="property"/> on instance <paramref name="sourceObject"/>.
            </summary>
            <param name="property">The property to set</param>
            <param name="sourceObject">The instance to set the value on</param>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.ReflectionExtensions">
            <summary>
            Contains extra extension methods for helping with reflection.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.GetTypeName(System.Object)">
            <summary>
            Returns the full type name for <paramref name="value"/>.
            </summary>
            <param name="value">Object to get type name from</param>
            <returns>The full type name for <paramref name="value"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.IsDefault``1(``0)">
            <summary>
            Checks if <paramref name="value"/> has the default value for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of object to check</typeparam>
            <param name="value">Object to check</param>
            <returns>If <paramref name="value"/> equals the default value for <typeparamref name="T"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.IsDefault(System.Object)">
            <summary>
            If <paramref name="value"/> has the default value for it's type.
            </summary>
            <param name="value">Object to check</param>
            <returns>If <paramref name="value"/> equals the default value for it's type</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.CreateDelegateForMethod(System.Object,System.String)">
            <summary>
            Creates a delegate for the method with name <paramref name="methodName"/> on the type of <paramref name="source"/>.
            </summary>
            <param name="source">The object to get the type from</param>
            <param name="methodName">The name of the method to create the delegate for</param>
            <returns>A delegate pointing to method <paramref name="methodName"/> on <paramref name="source"/></returns>
            <exception cref="T:System.ArgumentException">Thrown when no method with name <paramref name="methodName"/> could be found on the type of <paramref name="source"/></exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.CreateDelegateForMethod``1(System.Object,System.String)">
            <summary>
            Creates a delegate for the method with name <paramref name="methodName"/> on the type of <paramref name="source"/>.
            </summary>
            <typeparam name="T">The type of the delegate to return</typeparam>
            <param name="source">The object to get the type from</param>
            <param name="methodName">The name of the method to create the delegate for</param>
            <returns>A delegate pointing to method <paramref name="methodName"/> on <paramref name="source"/></returns>
            <exception cref="T:System.ArgumentException">Thrown when no method with name <paramref name="methodName"/> could be found on the type of <paramref name="source"/></exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.ReflectionExtensions.Invoke``1(System.Delegate,System.Object[])">
            <summary>
            Invokes <paramref name="delegateFunction"/> with optional arguments <paramref name="arguments"/> and casts the return value to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The return type of <paramref name="delegateFunction"/></typeparam>
            <param name="delegateFunction">The delegate to invoke</param>
            <param name="arguments">Optional arguments to invoke <paramref name="delegateFunction"/> with</param>
            <returns>The value returned from invoking <paramref name="delegateFunction"/></returns>
        </member>
        <member name="T:Sels.Core.Extensions.Reflection.TypeReflectionExtensions">
            <summary>
            Contains extension methods for <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetTypeOrDefault(System.Object)">
            <summary>
             Returns the type of <paramref name="source"/> if it's not null, otherwise return null.
            </summary>
            <param name="source">The object to get the type from</param>
            <returns>The type of <paramref name="source"/> if it is not null, otherwise false</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsContainer(System.Type)">
            <summary>
            Checks if type is a collection of some sorts.
            </summary>
            <param name="type">Type to check</param>
            <returns>Boolean indicating if type is an item container</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsEnumerable(System.Type)">
            <summary>
            Checks if <paramref name="type"/> is assignable to <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
            <param name="type">The type to check</param>
            <returns>If <paramref name="type"/> is assignable to <see cref="T:System.Collections.IEnumerable"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsTypedEnumerable(System.Type)">
            <summary>
            Checks if <paramref name="type"/> is assignable to <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="type">The type to check</param>
            <returns>If <paramref name="type"/> is assignable to <see cref="T:System.Collections.Generic.IEnumerable`1"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsNullable(System.Type)">
            <summary>
            Check if we can assign null to the type
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsString(System.Type)">
            <summary>
            Checks if <paramref name="type"/> is <see cref="T:System.String"/>.
            </summary>
            <param name="type">Type to check</param>
            <returns>If <paramref name="type"/> is <see cref="T:System.String"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsNumeric(System.Type)">
            <summary>
            Checks if <paramref name="type"/> is any of the numeric types.
            </summary>
            <param name="type">Type to check</param>
            <returns>If <paramref name="type"/> is any of the numeric types</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableFrom``1(System.Object)">
            <summary>
            Checks if an instance of <typeparamref name="TType"/> can be assigned to a variable with the same type as <paramref name="source"/>.
            </summary>
            <typeparam name="TType">Type to check</typeparam>
            <param name="source">Object to check against</param>
            <returns>Boolean indicating if an instance of <typeparamref name="TType"/> can be assigned to a variable with the same type as <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableFrom(System.Object,System.Type)">
            <summary>
            Checks if an instance of <paramref name="type"/> can be assigned to a variable with the same type as <paramref name="source"/>.
            </summary>
            <param name="source">Object to check against</param>
            <param name="type">Type to check</param>
            <returns>Boolean indicating if an instance of <paramref name="type"/> can be assigned to a variable with the same type as <paramref name="source"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableTo``1(System.Object)">
            <summary>
            Checks if <paramref name="source"/> can be assigned to a variable of type <typeparamref name="TType"/>.
            </summary>
            <typeparam name="TType">Type to check against</typeparam>
            <param name="source">Source object to check</param>
            <returns>Boolean indicating if <paramref name="source"/> can be assigned to <typeparamref name="TType"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableTo``1(System.Type)">
            <summary>
            Checks if an instance of <paramref name="source"/> can be assigned to a variable of type <typeparamref name="TType"/>.
            </summary>
            <typeparam name="TType">Type to check against</typeparam>
            <param name="source">Source type to check</param>
            <returns>Boolean indicating if an instance of <paramref name="source"/> can be assigned to <typeparamref name="TType"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableTo(System.Object,System.Type)">
            <summary>
            Checks if <paramref name="source"/> can be assigned to a variable of type <paramref name="type"/>.
            </summary>
            <param name="source">Source object to check</param>
            <param name="type">Type to check against</param>
            <returns>Boolean indicating if <paramref name="source"/> can be assigned to <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.IsAssignableTo(System.Type,System.Type)">
            <summary>
            Checks if an instance of <paramref name="sourceType"/> can be assigned to a variable of type <paramref name="type"/>.
            </summary>
            <param name="sourceType">Source type to check</param>
            <param name="type">Type to check against</param>
            <returns>Boolean indicating if an instance of <paramref name="sourceType"/> can be assigned to <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetElementTypeFromCollection(System.Type)">
            <summary>
            Tries to get the element type from <paramref name="containerType"/>.
            </summary>
            <param name="containerType">Type to get the element type from</param>
            <returns>The element type for <paramref name="containerType"/></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetElementTypeFromCollection(System.Object)">
            <summary>
            Tries to get the element type from <paramref name="container"/>.
            </summary>
            <param name="container">Object to get the element type from</param>
            <returns>The element type for <paramref name="container"/></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetDefaultValue(System.Type)">
            <summary>
            Returns the default value for <paramref name="type"/>.
            </summary>
            <param name="type">Type to return the default value from</param>
            <returns>Default value for <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetConstants(System.Type)">
            <summary>
            Gets all constant fields on <paramref name="type"/>.
            </summary>
            <param name="type">Type to get the constant fields from</param>
            <returns>All constant fields on <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetDisplayName(System.Type,System.Boolean)">
            <summary>
            Returns a display name where in case of a generic type the types are fully filled out.
            </summary>
            <param name="type">Type to get the display name for</param>
            <param name="includeNamespace">If the namespace needs to be included</param>
            <returns>The display name for <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetDisplayName(System.Text.StringBuilder,System.Type,System.Boolean)">
            <summary>
            Appends a display name where in case of a generic type the types are fully filled out to <paramref name="builder"/>.
            </summary>
            <param name="builder">The builder to append to</param>
            <param name="type">Type to get the display name for</param>
            <param name="includeNamespace">If the namespace needs to be included</param>
            <returns><paramref name="builder"/> for method chaining</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetBaseName(System.Type,System.Boolean)">
            <summary>
            Returns the type name of <paramref name="type"/> without any generic information.
            </summary>
            <param name="type">Type to get the name from</param>
            <param name="includeNamespace">If the namespace needs to be included</param>
            <returns>The type name for <paramref name="type"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetDelegateTypes(System.Reflection.MethodInfo)">
            <summary>
            Returns the return type and the parameter types in the right order so they can be used to create a delegate.
            </summary>
            <param name="method">The method to get the types from</param>
            <returns>The return type and the parameter types in the right order so they can be used to create a delegate</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.GetAsDelegateType(System.Reflection.MethodInfo)">
            <summary>
            Gets the generic <see cref="T:System.Action"/> or <see cref="T:System.Func`2"/> type that is equal to the definition of <paramref name="method"/>.
            </summary>
            <param name="method">The method to get the type for</param>
            <returns>The generic <see cref="T:System.Action"/> or <see cref="T:System.Func`2"/> type that is equal to the definition of <paramref name="method"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Construct``1(System.Type)">
            <summary>
            Creates an instance of <paramref name="type"/>.
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="type">Type to create object from</param>
            <returns>Constructed object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Construct``1(System.Type,System.Object[])">
            <summary>
            Creates an instance of <paramref name="type"/> with <paramref name="parameters"/> as constructor arguments.
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="type">Type to create object from</param>
            <param name="parameters">Constructor arguments</param>
            <returns>Constructed object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Construct(System.Type)">
            <summary>
            Creates an instance of <paramref name="type"/>.
            </summary>
            <param name="type">Type to create object from</param>
            <returns>Constructed object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Construct(System.Type,System.Object[])">
            <summary>
            Creates an instance of <paramref name="type"/> with <paramref name="parameters"/> as constructor arguments.
            </summary>
            <param name="type">Type to create object from</param>
            <param name="parameters">Constructor arguments</param>
            <returns>Constructed object</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.CanConstructWith(System.Type,System.Type[])">
            <summary>
            Checks if we can construct the type using the supplied argumentTypes
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.CanConstructWithArguments(System.Type,System.Object[])">
            <summary>
            Checks if we can construct the type using the supplied arguments
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.CanConstructWith``1(System.Type)">
            <summary>
            Checks if type has a constructor that takes T.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Is(System.Type,System.Type)">
            <summary>
            Checks if <paramref name="type"/> is the same as <paramref name="typeToCheck"/>.
            </summary>
            <param name="type">Type to check</param>
            <param name="typeToCheck">Type to compare to</param>
            <returns>Boolean indicating if <paramref name="type"/> and <paramref name="typeToCheck"/> are the same type</returns>
        </member>
        <member name="M:Sels.Core.Extensions.Reflection.TypeReflectionExtensions.Is``1(System.Type)">
            <summary>
            Checks if <paramref name="type"/> is the same as <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to compare to</typeparam>
            <param name="type">Type to check</param>
            <returns>Boolean indicating if <paramref name="type"/> and <typeparamref name="T"/> are the same type</returns>
        </member>
        <member name="T:Sels.Core.Extensions.ArgumentValidationExtensions">
            <summary>
            Contains extensions for validating the argumetns supplied to methods/constructors.
            </summary>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgument``1(``0,System.Predicate{``0},System.Func{``0,System.Exception})">
            <summary>
            Validates argument to see if it passes the condition. Throws exception from validationFailedExceptionFunc when it fails validation.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="condition">Condition that argument needs to pass</param>
            <param name="validationFailedExceptionFunc">Func that creates exception when validation fails. First arg is supplied argument</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgument``1(``0,System.Predicate{``0},System.String)">
            <summary>
            Validates argument to see if it passes the condition. Throws ArgumentException with validationFailedMessage when it fails validation.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="condition">Condition that argument needs to pass</param>
            <param name="validationFailedMessage">Message for ArgumentException when validation fails</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgument``1(``0,System.String)">
            <summary>
            Validates if argument is not null. Throws ArgumentNullException when argument is null.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotNullOrEmpty(System.String,System.String)">
            <summary>
            Validates if argument is not null, empty or whitespace. Throws ArgumentException when it is.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotNullOrWhitespace(System.String,System.String)">
            <summary>
            Validates if argument is not null or empty. Throws ArgumentException when it is.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentEndsWith(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Validates that <paramref name="argument"/> is not null and ends with <paramref name="comparator"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">What <paramref name="argument"/> must end with</param>
            <param name="option">How the strings should be compared</param>
            <returns><paramref name="argument"/></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentDoesNotEndWith(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Validates that <paramref name="argument"/> is not null and does not end with <paramref name="comparator"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">What <paramref name="argument"/> can't end with</param>
            <param name="option">How the strings should be compared</param>
            <returns><paramref name="argument"/></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentStartsWith(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Validates that <paramref name="argument"/> is not null and starts with <paramref name="comparator"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">What <paramref name="argument"/> must start with</param>
            <param name="option">How the strings should be compared</param>
            <returns><paramref name="argument"/></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentDoesNotStartWith(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Validates that <paramref name="argument"/> is not null and does not start with <paramref name="comparator"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">What <paramref name="argument"/> can't start with</param>
            <param name="option">How the strings should be compared</param>
            <returns><paramref name="argument"/></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentLarger``1(``0,System.String,``0)">
            <summary>
            Validates if argument is larger than comparator. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">Value to compare argument to</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentLargerOrEqual``1(``0,System.String,``0)">
            <summary>
            Validates if argument is larger or equal to comparator. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">Value to compare argument to</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentSmaller``1(``0,System.String,``0)">
            <summary>
            Validates if argument is smaller than comparator. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">Value to compare argument to</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentSmallerOrEqual``1(``0,System.String,``0)">
            <summary>
            Validates if argument is smaller or equal to comparator. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="comparator">Value to compare argument to</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentInRange``1(``0,System.String,``0,``0)">
            <summary>
            Validates if argument in range of startRange and endRange. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="startRange">Start value of range</param>
            <param name="endRange">End value of range</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotNullOrEmpty``2(``0,System.String)">
            <summary>
            Validates if argument is not null and contains at least 1 item. Throws ArgumentException when it does not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <typeparam name="TItem">Type of item in collection</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Validates if argument is not null and contains at least 1 item. Throws ArgumentException when it does not.
            </summary>
            <typeparam name="T">Type of item in collection</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotNullOrEmpty``1(``0[],System.String)">
            <summary>
            Validates if argument is not null and contains at least 1 item. Throws ArgumentException when it does not.
            </summary>
            <typeparam name="T">Type of item in collection</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentAssignableFrom``1(``0,System.String,System.Type)">
            <summary>
            Validates if argument is not null and is assignable from assignableType. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="assignableType">Type to check against</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentAssignableTo``1(``0,System.String,System.Type)">
            <summary>
            Validates if argument is not null and assignableType is assignable from the type of argument. Throws ArgumentException when it is not.
            </summary>
            <typeparam name="T">Type of argument</typeparam>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="assignableType">Type to check against</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentAssignableFrom(System.Type,System.String,System.Type)">
            <summary>
            Validates if argument is not null and is assignable from assignableType. Throws ArgumentException when it is not.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="assignableType">Type to check against</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentAssignableTo(System.Type,System.String,System.Type)">
            <summary>
            Validates if argument is not null and assignableType is assignable from the argument. Throws ArgumentException when it is not.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="assignableType">Type to check against</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentNotInterface(System.Type,System.String)">
            <summary>
            Validates if argument is not null and is not an interface type.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentCanBeContructedWith(System.Type,System.String,System.Type[])">
            <summary>
            Validates if an instance can be constructed from <paramref name="argument"/> using the supplied <paramref name="parameterTypes"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="parameterTypes">Contructor argument types in order</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentCanBeContructedWithArguments(System.Type,System.String,System.Object[])">
            <summary>
            Validates if an instance can be constructed from <paramref name="argument"/> using the supplied <paramref name="arguments"/>.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="parameterName">Method/Constructor parameter name</param>
            <param name="arguments">Contructor arguments in order</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="M:Sels.Core.Extensions.ArgumentValidationExtensions.ValidateArgumentExists``1(``0,System.String)">
            <summary>
            Validates if <paramref name="argument"/> is not null and exists on the file system.
            </summary>
            <param name="argument">Method/Constructor argument</param>
            <param name="validationFailedMessage">Message for ArgumentException when validation fails</param>
            <returns><paramref name="argument"/></returns>
        </member>
        <member name="T:Sels.Core.Helper">
            <summary>
            Static class with generic helper methods
            </summary>
        </member>
        <member name="T:Sels.Core.Helper.Enums">
            <summary>
            Helper methods for working with enums.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Enums.GetAll``1">
            <summary>
            Returns all values for enumeration <typeparamref name="TEnum"/>.
            </summary>
            <typeparam name="TEnum">Type of the enum to return the values from</typeparam>
            <returns>All values for enumeration <typeparamref name="TEnum"/></returns>
        </member>
        <member name="T:Sels.Core.Helper.FileSystem">
            <summary>
            Contains static helper methods for working with the filesystem.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.FileSystem.IsValidDirectoryPath(System.String)">
            <summary>
            Checks if <paramref name="path"/> is a valid directory path.
            </summary>
            <param name="path">The path string to validate</param>
            <returns>If <paramref name="path"/> is a valid directory</returns>
        </member>
        <member name="M:Sels.Core.Helper.FileSystem.IsValidFileName(System.String)">
            <summary>
            Checks if <paramref name="fileName"/> is a vlid filename path.
            </summary>
            <param name="fileName">The filename string to check</param>
            <returns>If <paramref name="fileName"/> is a valid filename</returns>
        </member>
        <member name="T:Sels.Core.Helper.Configuration">
            <summary>
            Contains helper methods for working with application configuration.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Configuration.BuildPathString(System.String,System.String[])">
            <summary>
            Builds a path string from <paramref name="key"/> and optionally <paramref name="sections"/> representing the configuration location. Used for tracing.
            </summary>
            <param name="key">The config key or section name</param>
            <param name="sections">Optional parent sections for <paramref name="key"/></param>
            <returns>A path string representing <paramref name="key"/> and <paramref name="sections"/></returns>
        </member>
        <member name="M:Sels.Core.Helper.Configuration.BuildDefaultConfigurationFile">
            <summary>
            Builds a new instance of <see cref="T:Microsoft.Extensions.Configuration.IConfiguration"/> using the default AppSettings.json file that resides besides the application exe.
            </summary>
            <returns>The IConfiguration created from the default configuration file</returns>
        </member>
        <member name="T:Sels.Core.Helper.App">
            <summary>
            Contains helper methods for running applications.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.App.OnExit(System.Action)">
            <summary>
            Registers the <paramref name="action"/> delegate that will be executed when the application closes.
            </summary>
            <param name="action">The delegate to execute when the application closes</param>
        </member>
        <member name="M:Sels.Core.Helper.App.OnExit(System.Action{System.Object,System.EventArgs})">
            <summary>
            Registers the <paramref name="action"/> delegate that will be executed when the application closes.
            </summary>
            <param name="action">The delegate to execute when the application closes</param>
        </member>
        <member name="M:Sels.Core.Helper.App.SetCurrentDirectoryToProcess">
            <summary>
            Sets the current directory to the directory of the executing process. This is to fix the config files when publishing as a self-contained app.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.App.SetCurrentDirectoryToExecutingAssembly">
            <summary>
            Sets the current directory to the directory of the executing process. This is to fix the config files when publishing as a self-contained app.
            </summary>
        </member>
        <member name="T:Sels.Core.Helper.Strings">
            <summary>
            Contains helper methods for working with strings.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Strings.JoinStrings(System.Object[])">
            <summary>
            Joins all strings returned from calling <paramref name="values"/> by calling <see cref="M:System.Object.ToString"/>.
            </summary>
            <param name="values">The objects the join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:Sels.Core.Helper.Strings.JoinStrings(System.Object,System.String[])">
            <summary>
            Joins all strings returned from calling <paramref name="values"/> by calling <see cref="M:System.Object.ToString"/> using the <see cref="M:System.Object.ToString"/> value from <paramref name="joinValue"/>.
            </summary>
            <param name="joinValue">The value to join <paramref name="values"/> with</param>
            <param name="values">The objects to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:Sels.Core.Helper.Strings.JoinStringsNewLine(System.String[])">
            <summary>
            Joins all strings returned from calling <paramref name="values"/> by calling <see cref="M:System.Object.ToString"/> using the environment new line character.
            </summary>
            <param name="values">The objects to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:Sels.Core.Helper.Strings.JoinStringsTab(System.String[])">
            <summary>
            Joins all strings returned from calling <paramref name="values"/> by calling <see cref="M:System.Object.ToString"/> using the tab character.
            </summary>
            <param name="values">The objects to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="T:Sels.Core.Helper.Lists">
            <summary>
            Contains helper methods for working with lists.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Lists.Combine``1(``0[])">
            <summary>
            Creates a new list using <paramref name="values"/>.
            </summary>
            <typeparam name="T">Type of values to add to list</typeparam>
            <param name="values">Values to add to list</param>
            <returns>List whose elements are equal to <paramref name="values"/></returns>
        </member>
        <member name="M:Sels.Core.Helper.Lists.Merge``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Merges all elements from the collections in <paramref name="values"/> into a single list.
            </summary>
            <typeparam name="T">Type of values to add to list</typeparam>
            <param name="values">Collection of collections whose values to add to the list</param>
            <returns>List whose elements are equal to the elements in the <paramref name="values"/> collections</returns>
        </member>
        <member name="T:Sels.Core.Helper.Collection">
            <summary>
            Contains static helper methods for working with collections.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Collection.EnumerateAll``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Creates an enumerator returning all elements in <paramref name="enumerators"/>. Nulls in <paramref name="enumerators"/> are ignored.
            </summary>
            <typeparam name="T">Type of element to return</typeparam>
            <param name="enumerators">List of enumerators to returns the elements from</param>
            <returns>An enumerator returning all elements in <paramref name="enumerators"/></returns>
        </member>
        <member name="M:Sels.Core.Helper.Collection.Enumerate``1(``0,``0[])">
            <summary>
            Create an enumerator returning <paramref name="value"/> and optionally all elements in <paramref name="values"/>.
            </summary>
            <typeparam name="T">Type of element to return</typeparam>
            <param name="value">The first value to return</param>
            <param name="values">Optional additional values to return</param>
            <returns>An enumerator returning <paramref name="value"/> and optionally all elements in <paramref name="values"/></returns>
        </member>
        <member name="M:Sels.Core.Helper.Collection.Enumerate``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an enumerator returning <paramref name="value"/> and optionally all elements in <paramref name="values"/>.
            </summary>
            <typeparam name="T">Type of element to return</typeparam>
            <param name="value">The first value to return</param>
            <param name="values">Optional additional values to return</param>
            <returns>An enumerator returning <paramref name="value"/> and optionally all elements in <paramref name="values"/></returns>
        </member>
        <member name="T:Sels.Core.Helper.Program">
            <summary>
            Contains helper methods for working with 
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Program.Run(System.String,System.String,System.String@,System.String@,System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILogger},System.Int32)">
            <summary>
            Runs program at <paramref name="programFileName"/> with <paramref name="arguments"/>.
            </summary>
            <param name="programFileName">Filename of program to run</param>
            <param name="arguments">Arguments for program</param>
            <param name="output">Standard output from program execution</param>
            <param name="error">Error output from program execution</param>
            <param name="killWaitTime">How long to wait for the process to exit after killing it. This is only applicable when the cancellation token is used</param>
            <param name="token">CancellationToken for stopping the execution of the process</param>
            <param name="loggers">Optional loggers for tracing</param>
            <returns>The program exit code</returns>
        </member>
        <member name="T:Sels.Core.Helper.Console">
            <summary>
            Contains helper methods for working with the console.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Console.Run(System.Action)">
            <summary>
            Helper method for running code in a console. Catches and logs exceptions and asks for a key press to exit.
            </summary>
            <param name="entryMethod">The action to execute</param>
        </member>
        <member name="M:Sels.Core.Helper.Console.Run(System.Action,System.Action)">
            <summary>
            Helper method for running code in a console. Catches and logs exceptions and asks for a key press to exit.
            </summary>
             <param name="entryMethod">The action to execute</param>
            <param name="exitHandler">The code to run when closing the console</param>
        </member>
        <member name="M:Sels.Core.Helper.Console.WriteLine(System.ConsoleColor,System.ConsoleColor,System.String)">
            <summary>
            Writes <paramref name="message"/> to the console using <paramref name="foregroundColor"/> as the text color and <paramref name="backgroundColor"/> as the background color.
            </summary>
            <param name="foregroundColor">The foreground color to use</param>
            <param name="backgroundColor">The background color to use</param>
            <param name="message">The message to write to the console</param>
        </member>
        <member name="M:Sels.Core.Helper.Console.WriteLine(System.ConsoleColor,System.String)">
            <summary>
            Writes <paramref name="message"/> to the console using <paramref name="foregroundColor"/> as the text color.
            </summary>
            <param name="foregroundColor">The foreground color to use</param>
            <param name="message">The message to write to the console</param>
        </member>
        <member name="T:Sels.Core.Helper.Random">
            <summary>
            Contains helper methods for generating random values.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Random.GetRandomInt(System.Int32,System.Int32)">
            <summary>
            Returns a random int larger or equal to <paramref name="min"/> and smaller or equal to <paramref name="max"/>.
            </summary>
            <param name="min">The lowest possible value to generate</param>
            <param name="max">The highest possible value to generate</param>
            <returns>A random int in range of <paramref name="min"/> and <paramref name="max"/></returns>
        </member>
        <member name="M:Sels.Core.Helper.Random.GetRandomDouble(System.Double,System.Double)">
            <summary>
            Returns a random double larger or equal to <paramref name="min"/> and smaller or equal to <paramref name="max"/>.
            </summary>
            <param name="min">The lowest possible value to generate</param>
            <param name="max">The highest possible value to generate</param>
            <returns>A random double in range of <paramref name="min"/> and <paramref name="max"/></returns>
        </member>
        <member name="T:Sels.Core.Helper.Expression">
            <summary>
            Contains static helper methods for working with expressions.
            </summary>
        </member>
        <member name="T:Sels.Core.Helper.Expression.Property">
            <summary>
            Static helper methods for working with expression resolving around properties.
            </summary>
        </member>
        <member name="M:Sels.Core.Helper.Expression.Property.ValidateNestedProperties(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo})">
            <summary>
            Validates that <paramref name="nestedProperties"/> are selected from root object of type <paramref name="expectedRoot"/>.
            </summary>
            <param name="expectedRoot">The expected reflected type of the first property</param>
            <param name="nestedProperties">The nested properties to check</param>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="T:System.IO.DirectoryInfoExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CreateIfNotExist(System.IO.DirectoryInfo)">
            <summary>
            Creates <paramref name="directory"/> if it does not exist.
            </summary>
            <param name="directory">The directory to create</param>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.IsEmpty(System.IO.DirectoryInfo)">
            <summary>
            Checks if <paramref name="directory"/> does not contain any sub directories and files.
            </summary>
            <param name="directory">The directory to check</param>
            <returns>True if <paramref name="directory"/> is empty, otherwise false</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.Clear(System.IO.DirectoryInfo)">
            <summary>
            Deletes all files and sub directories in <paramref name="directory"/>.
            </summary>
            <param name="directory">Directory to clear</param>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CopyTo(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Copies <paramref name="directory"/> to <paramref name="destinationDirectory"/>.
            </summary>
            <param name="directory">The directory to copy</param>
            <param name="destinationDirectory">The directory to copy to</param>
            <param name="overwrite">If destination files can be overwritten if they already exists</param>
            <returns>The copied directory</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CopyTo(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Copies <paramref name="directory"/> to <paramref name="destinationDirectory"/>.
            </summary>
            <param name="directory">The directory to copy</param>
            <param name="destinationDirectory">The directory to copy to</param>
            <param name="overwrite">If destination files can be overwritten if they already exists</param>
            <returns>The copied directory</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CopyContentTo(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Copies all sub directories and files from <paramref name="directory"/> to <paramref name="destinationDirectory"/>.
            </summary>
            <param name="directory">The directory to copy the content from</param>
            <param name="destinationDirectory">The directory to copy to</param>
            <param name="overwrite">If destination files can be overwritten if they already exists</param>
            <returns>The copied directory</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CopyContentTo(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Copies all sub directories and files from <paramref name="directory"/> to <paramref name="destinationDirectory"/>.
            </summary>
            <param name="directory">The directory to copy the content from</param>
            <param name="destinationDirectory">The directory to copy to</param>
            <param name="overwrite">If destination files can be overwritten if they already exists</param>
            <returns>The copied directory</returns>
        </member>
        <member name="T:System.IO.DriveInfoExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.IO.DriveInfo"/>.
            </summary>
        </member>
        <member name="T:System.IO.FileInfoExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.IO.FileInfo"/>.
            </summary>
        </member>
        <member name="M:System.IO.FileInfoExtensions.IsLocked(System.IO.FileInfo)">
            <summary>
            Checks if <paramref name="file"/> is locked and can't be written to.
            </summary>
            <param name="file">The files to check</param>
            <returns>True if <paramref name="file"/> can't be written to, otherwise false</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetExtensionName(System.IO.FileInfo)">
            <summary>
            Gets the extension from <paramref name="file"/> without the dot.
            </summary>
            <param name="file">The file to get the extension from</param>
            <returns>The extension of <paramref name="file"/></returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetNameWithoutExtension(System.IO.FileInfo)">
            <summary>
            Gets the file name without extension from <paramref name="file"/>.
            </summary>
            <param name="file">The file to get the name from</param>
            <returns>The file name without extension from <paramref name="file"/></returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.OpenWithWindowsExplorer(System.IO.FileInfo)">
            <summary>
            Opens <paramref name="file"/> using the windows file explorer.
            </summary>
            <param name="file">The file to open</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Read(System.IO.FileInfo)">
            <summary>
            Reads the file content from <paramref name="file"/>.
            </summary>
            <param name="file">File to read content from</param>
            <returns>File content of <paramref name="file"/></returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Create(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>
            Creates a new file using the filename of <paramref name="file"/> and writes <paramref name="content"/> into the file.
            </summary>
            <param name="file">File to write</param>
            <param name="content">Content to write into the file</param>
            <param name="overwrite">If we can overwrite the file if it already exists</param>
            <returns>Boolean indicating if the file was created</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Write(System.IO.FileInfo,System.String)">
            <summary>
            Writes <paramref name="content"/> to <paramref name="file"/>.
            </summary>
            <param name="file">The file to write to</param>
            <param name="content">The file content to write</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Clear(System.IO.FileInfo)">
            <summary>
            Replaces the file content of <paramref name="file"/> with an empty string.
            </summary>
            <param name="file">The file to clear</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Copies <paramref name="file"/> to directory <paramref name="destinationDirectory"/>.
            </summary>
            <param name="file">File to copy</param>
            <param name="destinationDirectory">Directory to copy file to</param>
            <param name="overwrite">If the target file can be overwritten if it already exists</param>
            <returns>The copied file</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Copies <paramref name="file"/> to directory <paramref name="destinationDirectory"/> with <paramref name="fileName"/> as the new file name.
            </summary>
            <param name="file">File to copy</param>
            <param name="destinationDirectory">Directory to copy file to</param>
            <param name="fileName">Filename of copied file</param>
            <param name="overwrite">If the target file can be overwritten if it already exists</param>
            <returns>The copied file</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.MoveTo(System.IO.FileInfo,System.IO.DirectoryInfo)">
            <summary>
            Moves <paramref name="file"/> to directory <paramref name="destinationDirectory"/>.
            </summary>
            <param name="file">File to move</param>
            <param name="destinationDirectory">Directory to move file to</param>
            <returns>The moved file</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.MoveTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.String)">
            <summary>
            Moves <paramref name="file"/> to directory <paramref name="destinationDirectory"/> with <paramref name="fileName"/> as the new file name.
            </summary>
            <param name="file">File to move</param>
            <param name="destinationDirectory">Directory to move file to</param>
            <param name="fileName">Filename of moved file</param>
            <returns>The moved file</returns>
        </member>
        <member name="T:System.IO.FileSystemInfoExtensions">
            <summary>
            Contains extension methods for working with <see cref="T:System.IO.FileSystemInfo"/>
            </summary>
        </member>
        <member name="M:System.IO.FileSystemInfoExtensions.GetDriveInfo(System.IO.FileSystemInfo)">
            <summary>
            Returns the drive info for the <paramref name="info"/> object.
            </summary>
            <param name="info">File system object to get drive info from</param>
            <returns>Drive info for <paramref name="info"/></returns>
        </member>
        <member name="T:System.GridExtensions">
            <summary>
            Contains extension methods for working with 2 dimensional arrays.
            </summary>
        </member>
        <member name="M:System.GridExtensions.GetRow(System.String[0:,0:],System.Int32)">
            <summary>
            Gets an array from all the elements in row <paramref name="rowIndex"/> in grid <paramref name="grid"/>.
            </summary>
            <param name="grid">The grid to get the row from</param>
            <param name="rowIndex">The index of the row to get</param>
            <returns>The columns of row at index <paramref name="rowIndex"/></returns>
        </member>
        <member name="T:System.IDisposableExtensions">
            <summary>
            Contains extension methods for <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="M:System.IDisposableExtensions.TryDispose(System.IDisposable,System.Action{System.Exception})">
            <summary>
            Try to dispose <paramref name="disposable"/>. Returns true when <paramref name="disposable"/> is disposed without throwing exceptions.
            </summary>
            <param name="disposable">Object to dispose</param>
            <param name="exceptionHandler">Optional exception handler</param>
            <returns>True if <paramref name="disposable"/> is not null and if <see cref="M:System.IDisposable.Dispose"/> could be called without any exceptions, otherwise false</returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions">
            <summary>
            Contains extensions for S<see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.InsertBefore``1(System.Collections.Generic.List{``0},System.Predicate{``0},``0)">
            <summary>
            Inserts <paramref name="value"/> in <paramref name="list"/> before the first item matching <paramref name="predicate"/>. If no matching item is found it added to <paramref name="list"/>. 
            </summary>
            <typeparam name="T">Element type of list</typeparam>
            <param name="list">List to add element in</param>
            <param name="predicate">Predicate for finding object to insert before</param>
            <param name="value">Object to insert</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.UpdateFirst``1(System.Collections.Generic.List{``0},Sels.Core.Delegates.Comparator{``0},``0)">
            <summary>
            Updates the first object in <paramref name="list"/> matching the <paramref name="comparator"/> and replaces it with <paramref name="value"/>.
            </summary>
            <typeparam name="T">Item type of <paramref name="list"/></typeparam>
            <param name="list">List to update value in</param>
            <param name="comparator">Comparator that tells which object to update</param>
            <param name="value">Value to update</param>
            <returns>Boolean indicating if <paramref name="list"/> was updated</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.UpdateAll``1(System.Collections.Generic.List{``0},Sels.Core.Delegates.Comparator{``0},``0)">
            <summary>
            Updates the all objects in <paramref name="list"/> matching the <paramref name="comparator"/> and replaces it with <paramref name="value"/>.
            </summary>
            <typeparam name="T">Item type of <paramref name="list"/></typeparam>
            <param name="list">List to update values in</param>
            <param name="comparator">Comparator that tells which objects to update</param>
            <param name="value">Value to update</param>
            <returns>Boolean indicating if <paramref name="list"/> was updated</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.DeleteFirst``1(System.Collections.Generic.List{``0},Sels.Core.Delegates.Comparator{``0},``0)">
            <summary>
            Deletes the first object in <paramref name="list"/> matching the <paramref name="comparator"/>.
            </summary>
            <typeparam name="T">Item type of <paramref name="list"/></typeparam>
            <param name="list">List to delete value in</param>
            <param name="comparator">Comparator that tells which object to delete</param>
            <param name="value">Value to delete</param>
            <returns>Boolean indicating if item in <paramref name="list"/> was deleted</returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.DeleteAll``1(System.Collections.Generic.List{``0},Sels.Core.Delegates.Comparator{``0},``0)">
            <summary>
            Deletes the all objects in <paramref name="list"/> matching the <paramref name="comparator"/>.
            </summary>
            <typeparam name="T">Item type of <paramref name="list"/></typeparam>
            <param name="list">List to delete values in</param>
            <param name="comparator">Comparator that tells which objects to delete</param>
            <param name="value">Value to delete</param>
            <returns>Boolean indicating if items in <paramref name="list"/> were deleted</returns>
        </member>
        <member name="T:System.NumberExtensions">
            <summary>
            Contains extension methods for working with numeric types.
            </summary>
        </member>
        <member name="M:System.NumberExtensions.ToNegative(System.Int32)">
            <summary>
            Converts <paramref name="number"/> to the negative value.
            </summary>
            <param name="number">Number to convert</param>
            <returns>A number equal or below 0</returns>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            Contains extension methods for <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:System.StringExtensions.FormatString(System.String,System.Object[])">
            <summary>
            Formats <paramref name="value"/> using <paramref name="parameters"/>.
            </summary>
            <param name="value">The string to format</param>
            <param name="parameters">The parameters to format <paramref name="value"/> with</param>
            <returns>The formatted string</returns>
        </member>
        <member name="M:System.StringExtensions.GetWithoutDigits(System.String)">
            <summary>
            Returns <paramref name="value"/> where all digits are removed.
            </summary>
            <param name="value">The value to remove the digits from</param>
            <returns><paramref name="value"/> with all digits removed</returns>
        </member>
        <member name="M:System.StringExtensions.GetWithoutWhitespace(System.String)">
            <summary>
            Returns <paramref name="value"/> where all whitespace characters are removed.
            </summary>
            <param name="value">The value to remove the whitespace from</param>
            <returns><paramref name="value"/> with all whitespace removed</returns>
        </member>
        <member name="M:System.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>
            Checks if <paramref name="value"/> is null or empty.
            </summary>
            <param name="value">The string to check</param>
            <returns>True if <paramref name="value"/> is either null or an empty string, otherwise false</returns>
        </member>
        <member name="M:System.StringExtensions.ContainsWhitespace(System.String)">
            <summary>
            Checks if <paramref name="value"/> contains any whitespace characters.
            </summary>
            <param name="value">The string to check</param>
            <returns>True if <paramref name="value"/> contains whitespace characters, otherwise false</returns>
        </member>
        <member name="M:System.StringExtensions.EscapeStrings(System.String,System.String,System.String[])">
            <summary>
            Escapes all <paramref name="stringsToEscape"/> in <paramref name="source"/> by prefixing <paramref name="escapeString"/> to each <paramref name="stringsToEscape"/>.
            </summary>
            <param name="source">String to escape string in</param>
            <param name="escapeString">String to prefix in front of <paramref name="stringsToEscape"/></param>
            <param name="stringsToEscape">Array with strings to escape</param>
            <returns><paramref name="source"/> with string escaped</returns>
        </member>
        <member name="M:System.StringExtensions.Contains(System.String,System.Char[])">
            <summary>
            Checks if <paramref name="value"/> contains one of the chars in <paramref name="chars"/>.
            </summary>
            <param name="value">String to check</param>
            <param name="chars">Chars to check that <paramref name="value"/> contains</param>
            <returns>If <paramref name="value"/> contains at one of the chars in <paramref name="chars"/></returns>
        </member>
        <member name="M:System.StringExtensions.ContainsAll(System.String,System.Char[])">
            <summary>
            Checks if <paramref name="value"/> contains all chars in <paramref name="chars"/>.
            </summary>
            <param name="value">String to check</param>
            <param name="chars">Chars to check that <paramref name="value"/> contains</param>
            <returns>If <paramref name="value"/> contains all chars in <paramref name="chars"/></returns>
        </member>
        <member name="M:System.StringExtensions.Contains(System.String,System.String[])">
            <summary>
            Checks if <paramref name="value"/> contains at least one substring in <paramref name="strings"/>.
            </summary>
            <param name="value">String to check</param>
            <param name="strings">Substrings to check that <paramref name="value"/> contains</param>
            <returns>If <paramref name="value"/> contains at least one substring in <paramref name="strings"/></returns>
        </member>
        <member name="M:System.StringExtensions.ContainsAll(System.String,System.String[])">
            <summary>
            Checks if <paramref name="value"/> contains all substrings in <paramref name="strings"/>
            </summary>
            <param name="value">String to check</param>
            <param name="strings">Substrings to check that <paramref name="value"/> contains</param>
            <returns>If <paramref name="value"/> contains all substrings in <paramref name="strings"/></returns>
        </member>
        <member name="M:System.StringExtensions.JoinString``1(System.Collections.Generic.IEnumerable{``0},System.Object)">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using the <see cref="M:System.Object.ToString"/> value from <paramref name="joinValue"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <param name="joinValue">The object to get the string to join from</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.JoinString``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using <see cref="F:Sels.Core.Constants.Strings.Comma"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.JoinStringNewLine``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using the environment new line character.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.JoinStringTab``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using <see cref="F:Sels.Core.Constants.Strings.Tab"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.JoinStringSpace``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using <see cref="F:Sels.Core.Constants.Strings.Space"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.JoinStringNoSpace``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Joins all <see cref="M:System.Object.ToString"/> strings from <paramref name="values"/> using <see cref="F:System.String.Empty"/>.
            </summary>
            <typeparam name="T">Type of the elements in <paramref name="values"/></typeparam>
            <param name="values">The values to join</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:System.StringExtensions.Split(System.String,System.String,System.StringSplitOptions)">
            <summary>
            Splits <paramref name="source"/> on <paramref name="splitValue"/>.
            </summary>
            <param name="source">String to split</param>
            <param name="splitValue">What value to split <paramref name="source"/> on</param>
            <param name="options">Option to omit empty string values from the return value</param>
            <returns>Substrings after splitting <paramref name="source"/></returns>
        </member>
        <member name="M:System.StringExtensions.SplitOnFirstOrDefault(System.String,System.Object,System.String@,System.StringSplitOptions)">
            <summary>
            Splits <paramref name="source"/> on the first occurance of <paramref name="splitValue"/>.
            </summary>
            <param name="source">String to split</param>
            <param name="splitValue">Value to split string with</param>
            <param name="other">The other values after splitting</param>
            <param name="options">Optional options for splitting the strings</param>
            <returns>The first value after splitting or the <paramref name="source"/> if the value could not be split</returns>
        </member>
        <member name="M:System.StringExtensions.SplitOnFirst(System.String,System.Object,System.String@,System.StringSplitOptions)">
            <summary>
            Splits <paramref name="source"/> on the first occurance of <paramref name="splitValue"/>. Throws <see cref="T:System.InvalidOperationException"/> if <paramref name="source"/> could not be split on <paramref name="splitValue"/>.
            </summary>
            <param name="source">String to split</param>
            <param name="splitValue">Value to split string with</param>
            <param name="other">The other values after splitting</param>
            <param name="options">Optional options for splitting the strings</param>
            <returns>The first value after splitting</returns>
        </member>
        <member name="M:System.StringExtensions.TrySplitOnFirst(System.String,System.Object,System.String@,System.String@,System.StringSplitOptions)">
            <summary>
            Splits <paramref name="source"/> on the first occurance of <paramref name="splitValue"/>.
            </summary>
            <param name="source">String to split</param>
            <param name="splitValue">Value to split string with</param>
            <param name="first">The first value after splitting</param>
            <param name="other">The other values after splitting</param>
            <param name="options">Optional options for splitting the strings</param>
            <returns>If <paramref name="source"/> could be split on <paramref name="splitValue"/></returns>
        </member>
        <member name="M:System.StringExtensions.SplitOnNewLine(System.String)">
            <summary>
            Splits <paramref name="source"/> using <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <param name="source">String to split</param>
            <returns><paramref name="source"/> split up using <see cref="P:System.Environment.NewLine"/></returns>
        </member>
        <member name="M:System.StringExtensions.AppendSpace(System.Text.StringBuilder)">
            <summary>
            Appends <see cref="F:Sels.Core.Constants.Strings.Space"/> to <paramref name="builder"/>.
            </summary>
            <param name="builder">The builder to append to</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:System.StringExtensions.AppendTab(System.Text.StringBuilder)">
            <summary>
            Appends <see cref="F:Sels.Core.Constants.Strings.Tab"/> to <paramref name="builder"/>.
            </summary>
            <param name="builder">The builder to append to</param>
            <returns>Current builder for method chaining</returns>
        </member>
        <member name="M:System.StringExtensions.Join(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{System.Object},System.Object)">
            <summary>
            Joins the <see cref="M:System.Object.ToString"/> values in <paramref name="values"/> using the <see cref="M:System.Object.ToString"/> of <paramref name="joinValue"/> and adds it to <paramref name="builder"/>.
            </summary>
            <param name="builder">The builder to append to</param>
            <param name="values">Enumerator returning the object to join the string values from</param>
            <param name="joinValue">Object containing the string value to join with</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:System.StringExtensions.Filter``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String,System.String})">
            <summary>
            Modifies <paramref name="value"/> by calling <paramref name="filterFunction"/> for each filter in <paramref name="source"/>.
            </summary>
            <typeparam name="T">Type of filter</typeparam>
            <param name="source">The filters to use</param>
            <param name="value">The value to modify</param>
            <param name="filterFunction">The function that will be called for each filter in <paramref name="source"/>. First arg is the filter, second arg is the current string value</param>
            <returns></returns>
        </member>
        <member name="M:System.StringExtensions.ToGrid(System.String,System.Func{System.String,System.Collections.Generic.IEnumerable{System.String}},System.Func{System.String,System.Collections.Generic.IEnumerable{System.String}},System.Boolean,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Transforms <paramref name="source"/> into a 2 dimensional array by dividing <paramref name="source"/> into rows and columns.
            </summary>
            <param name="source">The string to transform</param>
            <param name="rowSplitter">The delegate that will split up <paramref name="source"/> into rows</param>
            <param name="columnSplitter">The delegate that will split up rows into columns</param>
            <param name="ignoreMissingColumns">If no exception should be thown when a row has less columns than the expected column length. When set to true the missing columns will be null in the grid</param>
            <param name="ignoreExtraColumns">If no exception should be thrown when a row has more columns than the expected column length. When set to true the extra columns will be missing from the grid</param>
            <param name="expectedColumns">The expected amount of rows. When set to null the first row will determine the column count</param>
            <returns>The grid created from the rows and columns in <paramref name="source"/></returns>
            <exception cref="T:System.InvalidOperationException">Thown when column lengths don't match up with the expected amount unless disabled</exception>
        </member>
        <member name="M:System.StringExtensions.ExtractFromFormat(System.String,System.String,System.String,System.String[])">
            <summary>
            Extracts a value from <paramref name="value"/> where it is formatted according to <paramref name="format"/>.
            </summary>
            <param name="format">The format that <paramref name="value"/> is formatted in</param>
            <param name="parameter">The parameter to extract. Parameter is defined in <paramref name="format"/></param>
            <param name="value">The value to extract <paramref name="parameter"/> from</param>
            <param name="otherParameters">Optional parameters that are also included in the format. These are replaced so they match any characters</param>
            <returns>The extracted value or null if no value could be extracted</returns>
        </member>
    </members>
</doc>
