using Sels.Core.Async.TaskManagement;
using Sels.Core.Extensions;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using static Sels.Core.Delegates.Async;

namespace Sels.Core.Async.TaskManagement
{
    /// <summary>
    /// Exposes more options for <see cref="IManagedTask"/>(s) scheduled using a <see cref="ITaskManager"/>.
    /// </summary>
    /// <typeparam name="TInput">The input for the task to create</typeparam>
    /// <typeparam name="TOutput">The output generated by the task</typeparam>
    /// <typeparam name="TDerived">The type of the deriving type. Used for the fluent syntax</typeparam>
    public interface IManagedTaskCreationOptions<TInput, TOutput, TDerived> : IManagedTaskSharedCreationOptions<TInput, TOutput, TDerived>
    {
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived ContinueWith(Func<ITaskManager, IManagedTask, TInput, object, CancellationToken, IManagedTask?> continuationFactory);
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived ContinueWith(AsyncFunc<ITaskManager, IManagedTask, TInput, object, CancellationToken, IManagedTask?> continuationFactory);
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived ContinueWith(Func<ITaskManager, IManagedTask, TInput, object, CancellationToken, IManagedAnonymousTask?> continuationFactory);

        #region ContinueWith
        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnSuccess(AsyncFunc<ITaskManager, IManagedTask, TInput, TOutput, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnFail(AsyncFunc<ITaskManager, IManagedTask, TInput, Exception, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }

        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnSuccess(Func<ITaskManager, IManagedTask, TInput, TOutput, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnFail(Func<ITaskManager, IManagedTask, TInput, Exception, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }

        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnSuccess(Func<ITaskManager, IManagedTask, TInput, TOutput, CancellationToken, IManagedAnonymousTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        TDerived OnFail(Func<ITaskManager, IManagedTask, TInput, Exception, CancellationToken, IManagedAnonymousTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }
        #endregion
    }

    /// <summary>
    /// Exposes more options for <see cref="IManagedTask"/>(s) scheduled using a <see cref="ITaskManager"/>.
    /// </summary>
    /// <typeparam name="TInput">The input for the task to create</typeparam>
    /// <typeparam name="TOutput">The output generated by the task</typeparam>
    public interface IManagedTaskCreationOptions<TInput, TOutput> : IManagedTaskSharedCreationOptions<TInput, TOutput, IManagedTaskCreationOptions<TInput, TOutput>>
    {

    }
}
