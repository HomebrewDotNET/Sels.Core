using Sels.Core.Async.TaskManagement;
using Sels.Core.Extensions;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using static Sels.Core.Delegates.Async;

namespace Sels.Core.Async.TaskManagement
{
    /// <summary>
    /// Exposes more options for <see cref="IManagedAnonymousTask"/>(s) scheduled using a <see cref="ITaskManager"/>.
    /// </summary>
    /// <typeparam name="TInput">The input for the task to create</typeparam>
    /// <typeparam name="TOutput">The output generated by the task</typeparam>
    public interface IManagedAnonymousTaskCreationOptions<TInput, TOutput> : IManagedTaskSharedCreationOptions<TInput, TOutput, IManagedAnonymousTaskCreationOptions<TInput, TOutput>>
    {
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> ContinueWith(Func<ITaskManager, IManagedAnonymousTask, TInput, object, CancellationToken, IManagedTask?> continuationFactory);
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> ContinueWith(AsyncFunc<ITaskManager, IManagedAnonymousTask, TInput, object, CancellationToken, IManagedTask?> continuationFactory);
        /// <summary>
        /// Defines the factory for another managed task to run after the current one finishes executing regardless of the result.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> ContinueWith(Func<ITaskManager, IManagedAnonymousTask, TInput, object, CancellationToken, IManagedAnonymousTask?> continuationFactory);

        #region ContinueWith
        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnSuccess(AsyncFunc<ITaskManager, IManagedAnonymousTask, TInput, TOutput, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnFail(AsyncFunc<ITaskManager, IManagedAnonymousTask, TInput, Exception, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnSuccess(Func<ITaskManager, IManagedAnonymousTask, TInput, TOutput, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnFail(Func<ITaskManager, IManagedAnonymousTask, TInput, Exception, CancellationToken, IManagedTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }

        /// <summary>
        /// Defines the factory for another managed task to run after the current one successfully executes.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one successfully executes. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnSuccess(Func<ITaskManager, IManagedAnonymousTask, TInput, TOutput, CancellationToken, IManagedAnonymousTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is TOutput output) return continuationFactory(m, p, i, output, t);
                return null;
            });
        }
        /// <summary>
        /// Defines the factory for another managed task to run after the current one fails to execute.
        /// </summary>
        /// <param name="continuationFactory">Delegate that creates the managed task to run after the current one fails to execute. Null can be returned if no task needs to be scheduled</param>
        /// <returns>Current options for method chaining</returns>
        IManagedAnonymousTaskCreationOptions<TInput, TOutput> OnFail(Func<ITaskManager, IManagedAnonymousTask, TInput, Exception, CancellationToken, IManagedAnonymousTask?> continuationFactory)
        {
            continuationFactory.ValidateArgument(nameof(continuationFactory));

            return ContinueWith((m, p, i, o, t) =>
            {
                if (o is Exception exception) return continuationFactory(m, p, i, exception, t);
                return null;
            });
        }
        #endregion
    }
}
